import dotenv from 'dotenv';
dotenv.config();
import path from 'path';
import { tmpdir } from 'os';
import pLimit from 'p-limit';
import puppeteer from 'puppeteer';
import u from 'ak-tools';
const { NODE_ENV = "" } = process.env;
let { MIXPANEL_TOKEN = "" } = process.env;
if (!NODE_ENV) throw new Error("NODE_ENV is required");
let TEMP_DIR = NODE_ENV === 'dev' ? './tmp' : tmpdir();
TEMP_DIR = path.resolve(TEMP_DIR);

/**
 * @typedef PARAMS
 * @property {string} url URL to simulate
 * @property {number} users Number of users to simulate
 * @property {number} concurrency Number of users to simulate concurrently
 * @property {boolean} headless Whether to run headless or not
 * @property {boolean} inject Whether to inject external script
 * @property {token} token Mixpanel token
 */

/**
 * Main function to simulate user behavior.
 * @param {PARAMS} PARAMS 
 */
export default async function main(PARAMS = {}) {
	let { url = "https://aktunes.neocities.org/fixpanel/",
		users = 10,
		concurrency = 5,
		headless = true,
		inject = false,
		token = ""
	} = PARAMS;
	const limit = pLimit(concurrency);
	if (users > 25) users = 25;
	if (concurrency > 10) concurrency = 10;
	if (token) MIXPANEL_TOKEN = token;

	const userPromises = Array.from({ length: users }, (_, i) => {

		return limit(() => {
			if (NODE_ENV === "dev") console.log(`start user ${i + 1}...`);
			return simulateUser(url, headless, inject)
				.then((results) => {
					if (NODE_ENV === "dev") console.log(`end user ${i + 1}...`);
					return results;
				});
		});
	});

	const results = await Promise.all(userPromises).catch((error) => {
		if (NODE_ENV === "dev") debugger;
		throw error;
	});

	return results;
}

/**
 * Simulates a single user session with random actions, with a timeout to prevent hangs.
 * @param {string} url - The URL to visit.
 * @param {boolean} headless - Whether to run the browser headlessly.
 * @param {boolean} inject - Whether to inject external script.
 */
async function simulateUser(url, headless = true, inject = false) {
	const timeoutMs = 3 * 60 * 1000; // 3 minutes in milliseconds

	const browser = await puppeteer.launch({ headless, args: ['--disable-web-security', '--disable-features=IsolateOrigins,site-per-process'] });
	const page = await browser.newPage();
	await page.setViewport({ width: 1280, height: 720 });
	await page.goto(url);

	// Define a timeout promise
	const timeoutPromise = new Promise((resolve, reject) => 
		setTimeout(() => resolve('timeout'), timeoutMs)
	);

	// Define the user session simulation promise
	const simulationPromise = (async () => {
		if (inject) {
			const injectMixpanelString = injectMixpanel.toString();
			await page.evaluate((MIXPANEL_TOKEN, injectMixpanelFn) => {
				const injectedFunction = new Function(`return (${injectMixpanelFn})`)();
				injectedFunction(MIXPANEL_TOKEN);
			}, MIXPANEL_TOKEN, injectMixpanelString);
		}

		await u.sleep(100); // Ensure analytics script injection completes
		const persona = selectPersona(); // Generate user persona
		const actions = await simulateUserSession(page, persona); // Simulate actions
		await browser.close(); // Close browser when done
		return actions; // Return actions performed
	})();

	// Use Promise.race to terminate if simulation takes too long
	try {
		return await Promise.race([simulationPromise, timeoutPromise]);
	} catch (error) {
		// Handle timeout error (close browser if not already closed)
		await browser.close();
		if (NODE_ENV === "dev") console.error("simulateUser Error:", error);
		return { error: error.message, timedOut: true };
	}
}

/**
 * Simulates a user session on the page, following a persona-based action sequence.
 * @param {import('puppeteer').Page} page - Puppeteer page object.
 * @param {string} persona - User persona to simulate.
 */
async function simulateUserSession(page, persona) {
	await u.sleep(250); // Wait for page to load
	const actionSequence = generatePersonaActionSequence(persona);
	for (const action of actionSequence) {
		switch (action) {
			case "click":
				await clickStuff(page);
				if (coinFlip()) await wait();
				if (coinFlip()) await clickStuff(page);
				if (coinFlip()) await wait();
				if (coinFlip()) await clickStuff(page);
				if (coinFlip()) await clickStuff(page);
				if (coinFlip()) await wait();
				if (coinFlip()) await clickStuff(page);
				if (coinFlip()) await clickStuff(page)
				if (coinFlip()) await clickStuff(page);
				if (coinFlip()) await clickStuff(page);
				if (coinFlip()) await wait();
				if (coinFlip()) await clickStuff(page);
				break;
			case "scroll":
				await randomScroll(page);
				if (coinFlip()) await wait();
				if (coinFlip()) await randomScroll(page);
				if (coinFlip()) await wait();
				if (coinFlip()) await randomScroll(page);
				break;
			case "mouseMove":
				await randomMouseMove(page);
				if (coinFlip()) await wait();
				if (coinFlip()) await randomMouseMove(page);
				if (coinFlip()) await wait();
				if (coinFlip()) await randomMouseMove(page);
				break;
			case "wait":
				await wait();
				break;
		}

		await u.sleep(250); // wait for data to flush
	}
	return {
		persona: personas[persona],
		personaLabel: persona,
		actionSequence
	};
}

// User personas with different action weightings
const personas = {
	quickScroller: { scroll: 0.6, mouseMove: 0.2, click: 0.1, wait: 0.1 },
	carefulReader: { scroll: 0.3, mouseMove: 0.3, click: 0.2, wait: 0.2 },
	frequentClicker: { scroll: 0.2, mouseMove: 0.3, click: 0.6, wait: 0.1 },
	noWaiting: { scroll: 0.2, mouseMove: 0.2, click: 0.7, wait: 0.05 },
	casualBrowser: { scroll: 0.4, mouseMove: 0.3, click: 0.2, wait: 0.15 },
	hoveringObserver: { scroll: 0.2, mouseMove: 0.6, click: 0.1, wait: 0.3 },
	intenseReader: { scroll: 0.15, mouseMove: 0.3, click: 0.1, wait: 0.4 },
	impulsiveScroller: { scroll: 0.7, mouseMove: 0.2, click: 0.1, wait: 0.05 },
	deepDiver: { scroll: 0.25, mouseMove: 0.4, click: 0.3, wait: 0.25 },
	explorer: { scroll: 0.5, mouseMove: 0.4, click: 0.3, wait: 0.1 }
};

/**
 * Selects a random persona.
 */
function selectPersona() {
	const personaKeys = Object.keys(personas);
	return personaKeys[Math.floor(Math.random() * personaKeys.length)];
}

/**
 * Generates an action sequence based on a persona's weighting.
 * @param {string} persona - The selected persona.
 */
function generatePersonaActionSequence(persona) {
	const personaWeights = personas[persona];
	const actionTypes = Object.keys(personaWeights);
	return generateWeightedRandomActionSequence(actionTypes, personaWeights);
}

/**
 * Generates a weighted random action sequence.
 * @param {Array} actionTypes - List of possible actions.
 * @param {Object} weights - Weighting for each action.
 */
function generateWeightedRandomActionSequence(actionTypes, weights) {
	const sequence = [];
	const length = u.rand(42, 100);
	for (let i = 0; i < length; i++) {
		const action = weightedRandom(actionTypes, weights);
		sequence.push(action);
	}
	return sequence;
}

// Core action functions

async function clickStuff(page) {
	try {
		const elements = await page.$$('a, button, input[type="submit"], [role="button"], [onclick]');
		if (elements.length === 0) throw new Error("No clickable elements found.");

		const element = elements[Math.floor(Math.random() * elements.length)];
		const boundingBox = await element.boundingBox();
		if (!boundingBox) throw new Error("Bounding box not found.");

		const { x, y, width, height } = boundingBox;
		const targetX = x + width / 2 + u.rand(-5, 5);
		const targetY = y + height / 2 + u.rand(-5, 5);

		// Check if element is a link and has an href attribute
		const tagName = await page.evaluate(el => el.tagName.toLowerCase(), element);
		const href = await page.evaluate(el => el.getAttribute('href'), element);

		if (tagName === 'a' && href) {
			// Register the click for analytics by clicking with the `metaKey` (cmd on macOS)
			await moveMouse(page, u.rand(0, page.viewport().width), u.rand(0, page.viewport().height), targetX, targetY);
			await page.mouse.click(targetX, targetY, { modifiers: ['Meta'] });
		} else {
			// Move the mouse and click as usual for non-link elements
			await moveMouse(page, u.rand(0, page.viewport().width), u.rand(0, page.viewport().height), targetX, targetY);
			await page.mouse.click(targetX, targetY);
		}

		await u.sleep(u.rand(100, 300)); // Simulate response time
		if (NODE_ENV === "dev") console.log('click!');
		return true;
	} catch (error) {
		// console.error("clickStuff Error:", error);
		// if (NODE_ENV === "dev") debugger;
		return false;
	}
}


async function randomScroll(page) {
	try {
		const scrollOptions = [
			() => page.evaluate(() => window.scrollBy(0, Math.random() * window.innerHeight / 2)),
			() => page.evaluate(() => window.scrollTo({ top: document.body.scrollHeight * Math.random(), behavior: 'smooth' })),
			() => page.evaluate(() => window.scrollBy({ top: window.innerHeight * (Math.random() < 0.5 ? 1 : -1), behavior: 'smooth' })),
			() => page.evaluate(() => window.scrollTo({ top: 0, behavior: 'smooth' })),
			() => page.evaluate(() => window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' }))
		];
		await scrollOptions[Math.floor(Math.random() * scrollOptions.length)]();
		if (NODE_ENV === "dev") console.log('scroll!');
		return true;
	}
	catch (e) {
		return false;
	}
}

async function randomMouseMove(page) {
	const startX = u.rand(0, page.viewport().width);
	const startY = u.rand(0, page.viewport().height);
	const endX = u.rand(0, page.viewport().width);
	const endY = u.rand(0, page.viewport().height);
	return await moveMouse(page, startX, startY, endX, endY);
}

async function moveMouse(page, startX, startY, endX, endY) {
	try {
		// Increase step distance to reduce total number of steps
		const stepDistance = u.rand(5, 20); // Increase from 5 to 15 pixels per step
		const steps = Math.ceil(Math.max(Math.abs(endX - startX), Math.abs(endY - startY)) / stepDistance);
		const deltaX = (endX - startX) / steps;
		const deltaY = (endY - startY) / steps;
		let currentX = startX;
		let currentY = startY;

		for (let i = 0; i < steps; i++) {
			// Reduce sine curve adjustment for smoother movement
			const curveX = currentX + deltaX + Math.sin((i / steps) * Math.PI) * u.rand(-2, 2); // Reduced from -10, 10
			const curveY = currentY + deltaY + Math.sin((i / steps) * Math.PI) * u.rand(-2, 2);

			// Move the mouse to the calculated position
			await page.mouse.move(curveX, curveY);

			// Decrease the sleep frequency and duration to make movement faster
			if (u.rand(0, 100) < 10) await u.sleep(u.rand(10, 30)); // Reduced frequency and duration

			// Update current position
			currentX = curveX;
			currentY = curveY;
		}

		// Final mouse move to the exact end point
		await page.mouse.move(endX, endY);
		await u.sleep(u.rand(50, 100)); // Final hesitation reduced

		if (NODE_ENV === "dev") console.log('mouse!');
		return true;
	} catch (e) {
		return false;
	}
}

// Utility wait functions
async function wait() {
	await u.sleep(u.rand(42, 420));
}

/**
 * Helper to pick a random item from a list with weights.
 * @param {Array} items - List of items to pick from.
 * @param {Object} weights - Object with item keys and their weights.
 * @returns {any} Selected item based on weights.
 */
function weightedRandom(items, weights) {
	const totalWeight = items.reduce((sum, item) => sum + weights[item], 0);
	const randomValue = Math.random() * totalWeight;
	let cumulativeWeight = 0;

	for (const item of items) {
		cumulativeWeight += weights[item];
		if (randomValue < cumulativeWeight) return item;
	}
}


function coinFlip() {
	return Math.random() < 0.5;
}


function injectMixpanel(token = process.env.MIXPANEL_TOKEN || "") {
	function reset() {
		console.log('resetting....\n\n');
		if (mixpanel) {
			if (mixpanel.ez) {
				mixpanel.ez.reset();
			}
		}
	}

	function generateName() {
		var adjs = [
			"autumn", "hidden", "bitter", "misty", "silent", "empty", "dry", "dark",
			"summer", "icy", "delicate", "quiet", "white", "cool", "spring", "winter",
			"patient", "twilight", "dawn", "crimson", "wispy", "weathered", "blue",
			"billowing", "broken", "cold", "damp", "falling", "frosty", "green",
			"long", "late", "lingering", "bold", "little", "morning", "muddy", "old",
			"red", "rough", "still", "small", "sparkling", "throbbing", "shy",
			"wandering", "withered", "wild", "black", "young", "holy", "solitary",
			"fragrant", "aged", "snowy", "proud", "floral", "restless", "divine",
			"polished", "ancient", "purple", "lively", "nameless", "gentle", "gleaming", "furious", "luminous", "obscure", "poised", "shimmering", "swirling",
			"sombre", "steamy", "whispering", "jagged", "melodic", "moonlit", "starry", "forgotten",
			"peaceful", "restive", "rustling", "sacred", "ancient", "haunting", "solitary", "mysterious",
			"silver", "dusky", "earthy", "golden", "hallowed", "misty", "roaring", "serene", "vibrant",
			"stalwart", "whimsical", "timid", "tranquil", "vast", "youthful", "zephyr", "raging",
			"sapphire", "turbulent", "whirling", "sleepy", "ethereal", "tender", "unseen", "wistful"
		];

		var nouns = [
			"waterfall", "river", "breeze", "moon", "rain", "wind", "sea", "morning",
			"snow", "lake", "sunset", "pine", "shadow", "leaf", "dawn", "glitter",
			"forest", "hill", "cloud", "meadow", "sun", "glade", "bird", "brook",
			"butterfly", "bush", "dew", "dust", "field", "fire", "flower", "firefly",
			"feather", "grass", "haze", "mountain", "night", "pond", "darkness",
			"snowflake", "silence", "sound", "sky", "shape", "surf", "thunder",
			"violet", "water", "wildflower", "wave", "water", "resonance", "sun",
			"wood", "dream", "cherry", "tree", "fog", "frost", "voice", "paper",
			"frog", "smoke", "star", "glow", "wave", "riverbed", "cliff", "deluge", "prairie", "creek", "ocean",
			"peak", "valley", "starlight", "quartz", "woodland", "marsh", "earth", "canopy",
			"petal", "stone", "orb", "gale", "bay", "canyon", "watercourse", "vista", "raindrop",
			"boulder", "grove", "plateau", "sand", "mist", "tide", "blossom", "leaf", "flame",
			"shade", "coil", "grotto", "pinnacle", "scallop", "serenity", "abyss", "skyline",
			"drift", "echo", "nebula", "horizon", "crest", "wreath", "twilight", "balm", "glimmer"
		];


		var adj = adjs[Math.floor(Math.random() * adjs.length)]; // http://stackoverflow.com/a/17516862/103058
		var noun = nouns[Math.floor(Math.random() * nouns.length)];
		var MIN = 1000;
		var MAX = 9999;
		var num = Math.floor(Math.random() * ((MAX + 1) - MIN)) + MIN;

		return adj + '-' + noun + '-' + num;

	}

	const PARAMS = qsToObj(window.location.search);
	let { user = "", project_token = "", ...restParams } = PARAMS;
	if (!restParams) restParams = {};
	if (!project_token) project_token = token;
	if (!project_token) throw new Error("Project token is required when injecting mixpanel.");

	// Function that contains the code to run after the script is loaded
	function EMBED_TRACKING() {
		if (window.mixpanel) {
			mixpanel.init(project_token, {
				loaded: function (mp) {
					mp.register(restParams);
					const name = generateName();
					if (!user) user = name;
					mp.identify(user);
					mp.people.set({ $name: user, $email: user });
					const welcome = 'mixpanel loaded; your id is\n\n ---------------- \n\n ' + user + '\n\n ---------------- \n';
					console.log(welcome);
					mp.track('page enter');
					window.addEventListener("beforeunload", () => {
						mp.track("page exit", {}, { transport: "sendBeacon", send_immediately: true });
					});

					window.addEventListener("click", () => {
						mp.track("page click");
					});

					window.addEventListener("resize", () => {
						mp.track("page resize");
					});

					window.addEventListener("beforeprint", () => {
						mp.track("print", props);
					});

					window.addEventListener("visibilitychange", function () {
						if ((document.hidden || document.visibilityState === "hidden")) {
							mp.track("page lost focus");
						} else {
							//only called if page has lost focus
							if (this.hasVisibilityChanged) mp.track("page regained focus");
						}
					});

					document.addEventListener("fullscreenchange", function () {
						if (document.fullscreenElement) {
							mp.track("page fullscreen: on");
						} else {
							mp.track("page fullscreen: off");
						}
					});
					window.addEventListener("error", errEv => {
						mp.track("page error");
					});
					window.addEventListener("cut", clipEv => {
						mp.track("cut");
					});
					window.addEventListener("copy", clipEv => {
						mp.track("copy");
					});
					window.addEventListener("paste", clipEv => {
						mp.track("paste");
					});

					let scrollTimeout;
					const scrollThreshold = 200; // in ms, to define "stopped scrolling"

					// Add the scroll event listener
					window.addEventListener("scroll", () => {
						// Clear any previous scroll timeout
						clearTimeout(scrollTimeout);
						// Set a timeout to fire the scroll tracking only when scroll activity stops
						scrollTimeout = setTimeout(() => {
							mp.track("page scroll"); // Track the discrete scroll event
						}, scrollThreshold);
					});

					console.log('all tracking attached')

				},
				record_sessions_percent: 100,
				record_inline_images: true,
				record_collect_fonts: true,
				record_mask_text_selector: "getEverythingInSight",
				ignore_dnt: true,
				batch_flush_interval_ms: 0,
				api_payload_format: 'json',
				api_host: "https://express-proxy-lmozz6xkha-uc.a.run.app",
				debug: true,
				persistence: "localStorage",
			});
		}
	}

	function qsToObj(queryString) {
		try {
			const parsedQs = new URLSearchParams(queryString);
			const params = Object.fromEntries(parsedQs);
			return params;
		}

		catch (e) {
			return {};
		}
	}
	// Load the external script and run myCode when it's done
	// loadScript(externalScript, EMBED_EZ_TRACK);
	//prettier-ignore
	(() => { var e, t; function r(e) { const t = null == e ? void 0 : e.host; return Boolean((null == t ? void 0 : t.shadowRoot) === e); } function n(e) { return "[object ShadowRoot]" === Object.prototype.toString.call(e); } function o(e) { try { const r = e.rules || e.cssRules; return r ? ((t = Array.from(r, i).join("")).includes(" background-clip: text;") && !t.includes(" -webkit-background-clip: text;") && (t = t.replace(" background-clip: text;", " -webkit-background-clip: text; background-clip: text;")), t) : null; } catch (e) { return null; } var t; } function i(e) { let t; if (function (e) { return "styleSheet" in e; }(e)) try { t = o(e.styleSheet) || function (e) { const { cssText: t } = e; if (t.split('"').length < 3) return t; const r = ["@import", `url(${JSON.stringify(e.href)})`]; return "" === e.layerName ? r.push("layer") : e.layerName && r.push(`layer(${e.layerName})`), e.supportsText && r.push(`supports(${e.supportsText})`), e.media.length && r.push(e.media.mediaText), r.join(" ") + ";"; }(e); } catch (e) { } else if (function (e) { return "selectorText" in e; }(e) && e.selectorText.includes(":")) return function (e) { const t = /(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm; return e.replace(t, "$1\\$2"); }(e.cssText); return t || e.cssText; } (t = e || (e = {}))[t.Document = 0] = "Document", t[t.DocumentType = 1] = "DocumentType", t[t.Element = 2] = "Element", t[t.Text = 3] = "Text", t[t.CDATA = 4] = "CDATA", t[t.Comment = 5] = "Comment"; var s = class { constructor() { this.idNodeMap = new Map, this.nodeMetaMap = new WeakMap; } getId(e) { var t; if (!e) return -1; const r = null === (t = this.getMeta(e)) || void 0 === t ? void 0 : t.id; return null != r ? r : -1; } getNode(e) { return this.idNodeMap.get(e) || null; } getIds() { return Array.from(this.idNodeMap.keys()); } getMeta(e) { return this.nodeMetaMap.get(e) || null; } removeNodeFromMap(e) { const t = this.getId(e); this.idNodeMap.delete(t), e.childNodes && e.childNodes.forEach((e => this.removeNodeFromMap(e))); } has(e) { return this.idNodeMap.has(e); } hasNode(e) { return this.nodeMetaMap.has(e); } add(e, t) { const r = t.id; this.idNodeMap.set(r, e), this.nodeMetaMap.set(e, t); } replace(e, t) { const r = this.getNode(e); if (r) { const e = this.nodeMetaMap.get(r); e && this.nodeMetaMap.set(t, e); } this.idNodeMap.set(e, t); } reset() { this.idNodeMap = new Map, this.nodeMetaMap = new WeakMap; } }; function a({ element: e, maskInputOptions: t, tagName: r, type: n, value: o, maskInputFn: i }) { let s = o || ""; const a = n && c(n); return (t[r.toLowerCase()] || a && t[a]) && (s = i ? i(s, e) : "*".repeat(s.length)), s; } function c(e) { return e.toLowerCase(); } var u = "__rrweb_original__"; function l(e) { const t = e.type; return e.hasAttribute("data-rr-is-password") ? "password" : t ? c(t) : null; } function p(e, t) { var r; let n; try { n = new URL(e, null != t ? t : window.location.href); } catch (e) { return null; } const o = n.pathname.match(/\.([0-9a-z]+)(?:$)/i); return null !== (r = null == o ? void 0 : o[1]) && void 0 !== r ? r : null; } var d, h, f = 1, m = new RegExp("[^a-z0-9-_:]"), _ = -2; function g() { return f++; } var y = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm, v = /^(?:[a-z+]+:)?\/\//i, b = /^www\..*/i, S = /^(data:)([^,]*),(.*)/i; function k(e, t) { return (e || "").replace(y, ((e, r, n, o, i, s) => { const a = n || i || s, c = r || o || ""; if (!a) return e; if (v.test(a) || b.test(a)) return `url(${c}${a}${c})`; if (S.test(a)) return `url(${c}${a}${c})`; if ("/" === a[0]) return `url(${c}${function (e) { let t = ""; return t = e.indexOf("//") > -1 ? e.split("/").slice(0, 3).join("/") : e.split("/")[0], t = t.split("?")[0], t; }(t) + a}${c})`; const u = t.split("/"), l = a.split("/"); u.pop(); for (const e of l) "." !== e && (".." === e ? u.pop() : u.push(e)); return `url(${c}${u.join("/")}${c})`; })); } var w = /^[^ \t\n\r\u000c]+/, I = /^[, \t\n\r\u000c]+/; function M(e, t) { if (!t || "" === t.trim()) return t; const r = e.createElement("a"); return r.href = t, r.href; } function C(e) { return Boolean("svg" === e.tagName || e.ownerSVGElement); } function x() { const e = document.createElement("a"); return e.href = "", e.href; } function E(e, t, r, n) { return n ? "src" === r || "href" === r && ("use" !== t || "#" !== n[0]) || "xlink:href" === r && "#" !== n[0] ? M(e, n) : "background" !== r || "table" !== t && "td" !== t && "th" !== t ? "srcset" === r ? function (e, t) { if ("" === t.trim()) return t; let r = 0; function n(e) { let n; const o = e.exec(t.substring(r)); return o ? (n = o[0], r += n.length, n) : ""; } const o = []; for (; n(I), !(r >= t.length);) { let i = n(w); if ("," === i.slice(-1)) i = M(e, i.substring(0, i.length - 1)), o.push(i); else { let n = ""; i = M(e, i); let s = !1; for (; ;) { const e = t.charAt(r); if ("" === e) { o.push((i + n).trim()); break; } if (s) ")" === e && (s = !1); else { if ("," === e) { r += 1, o.push((i + n).trim()); break; } "(" === e && (s = !0); } n += e, r += 1; } } } return o.join(", "); }(e, n) : "style" === r ? k(n, x()) : "object" === t && "data" === r ? M(e, n) : n : M(e, n) : n; } function O(e, t, r) { return ("video" === e || "audio" === e) && "autoplay" === t; } function T(e, t, r) { if (!e) return !1; if (e.nodeType !== e.ELEMENT_NODE) return !!r && T(e.parentNode, t, r); for (let r = e.classList.length; r--;) { const n = e.classList[r]; if (t.test(n)) return !0; } return !!r && T(e.parentNode, t, r); } function R(e, t, r, n) { try { const o = e.nodeType === e.ELEMENT_NODE ? e : e.parentElement; if (null === o) return !1; if ("string" == typeof t) { if (n) { if (o.closest(`.${t}`)) return !0; } else if (o.classList.contains(t)) return !0; } else if (T(o, t, n)) return !0; if (r) if (n) { if (o.closest(r)) return !0; } else if (o.matches(r)) return !0; } catch (e) { } return !1; } function D(t, r) { const { doc: n, mirror: i, blockClass: s, blockSelector: p, needsMask: f, inlineStylesheet: _, maskInputOptions: g = {}, maskTextFn: y, maskInputFn: v, dataURLOptions: b = {}, inlineImages: S, recordCanvas: w, keepIframeSrcFn: I, newlyAddedElement: M = !1 } = r, T = function (e, t) { if (!t.hasNode(e)) return; const r = t.getId(e); return 1 === r ? void 0 : r; }(n, i); switch (t.nodeType) { case t.DOCUMENT_NODE: return "CSS1Compat" !== t.compatMode ? { type: e.Document, childNodes: [], compatMode: t.compatMode } : { type: e.Document, childNodes: [] }; case t.DOCUMENT_TYPE_NODE: return { type: e.DocumentType, name: t.name, publicId: t.publicId, systemId: t.systemId, rootId: T }; case t.ELEMENT_NODE: return function (t, r) { const { doc: n, blockClass: i, blockSelector: s, inlineStylesheet: p, maskInputOptions: f = {}, maskInputFn: _, dataURLOptions: g = {}, inlineImages: y, recordCanvas: v, keepIframeSrcFn: b, newlyAddedElement: S = !1, rootId: w } = r, I = function (e, t, r) { try { if ("string" == typeof t) { if (e.classList.contains(t)) return !0; } else for (let r = e.classList.length; r--;) { const n = e.classList[r]; if (t.test(n)) return !0; } if (r) return e.matches(r); } catch (e) { } return !1; }(t, i, s), M = function (e) { if (e instanceof HTMLFormElement) return "form"; const t = c(e.tagName); return m.test(t) ? "div" : t; }(t); let T = {}; const R = t.attributes.length; for (let e = 0; e < R; e++) { const r = t.attributes[e]; O(M, r.name, r.value) || (T[r.name] = E(n, M, c(r.name), r.value)); } if ("link" === M && p) { const e = Array.from(n.styleSheets).find((e => e.href === t.href)); let r = null; e && (r = o(e)), r && (delete T.rel, delete T.href, T._cssText = k(r, e.href)); } if ("style" === M && t.sheet && !(t.innerText || t.textContent || "").trim().length) { const e = o(t.sheet); e && (T._cssText = k(e, x())); } if ("input" === M || "textarea" === M || "select" === M) { const e = t.value, r = t.checked; "radio" !== T.type && "checkbox" !== T.type && "submit" !== T.type && "button" !== T.type && e ? T.value = a({ element: t, type: l(t), tagName: M, value: e, maskInputOptions: f, maskInputFn: _ }) : r && (T.checked = r); } "option" === M && (t.selected && !f.select ? T.selected = !0 : delete T.selected); if ("canvas" === M && v) if ("2d" === t.__context) (function (e) { const t = e.getContext("2d"); if (!t) return !0; for (let r = 0; r < e.width; r += 50)for (let n = 0; n < e.height; n += 50) { const o = t.getImageData, i = u in o ? o[u] : o; if (new Uint32Array(i.call(t, r, n, Math.min(50, e.width - r), Math.min(50, e.height - n)).data.buffer).some((e => 0 !== e))) return !1; } return !0; })(t) || (T.rr_dataURL = t.toDataURL(g.type, g.quality)); else if (!("__context" in t)) { const e = t.toDataURL(g.type, g.quality), r = document.createElement("canvas"); r.width = t.width, r.height = t.height; e !== r.toDataURL(g.type, g.quality) && (T.rr_dataURL = e); } if ("img" === M && y) { d || (d = n.createElement("canvas"), h = d.getContext("2d")); const e = t, r = e.crossOrigin; e.crossOrigin = "anonymous"; const o = () => { e.removeEventListener("load", o); try { d.width = e.naturalWidth, d.height = e.naturalHeight, h.drawImage(e, 0, 0), T.rr_dataURL = d.toDataURL(g.type, g.quality); } catch (t) { console.warn(`Cannot inline img src=${e.currentSrc}! Error: ${t}`); } r ? T.crossOrigin = r : e.removeAttribute("crossorigin"); }; e.complete && 0 !== e.naturalWidth ? o() : e.addEventListener("load", o); } if ("audio" === M || "video" === M) { const e = T; e.rr_mediaState = t.paused ? "paused" : "played", e.rr_mediaCurrentTime = t.currentTime, e.rr_mediaPlaybackRate = t.playbackRate, e.rr_mediaMuted = t.muted, e.rr_mediaLoop = t.loop, e.rr_mediaVolume = t.volume; } S || (t.scrollLeft && (T.rr_scrollLeft = t.scrollLeft), t.scrollTop && (T.rr_scrollTop = t.scrollTop)); if (I) { const { width: e, height: r } = t.getBoundingClientRect(); T = { class: T.class, rr_width: `${e}px`, rr_height: `${r}px` }; } "iframe" !== M || b(T.src) || (t.contentDocument || (T.rr_src = T.src), delete T.src); let D; try { customElements.get(M) && (D = !0); } catch (e) { } return { type: e.Element, tagName: M, attributes: T, childNodes: [], isSVG: C(t) || void 0, needBlock: I, rootId: w, isCustom: D }; }(t, { doc: n, blockClass: s, blockSelector: p, inlineStylesheet: _, maskInputOptions: g, maskInputFn: v, dataURLOptions: b, inlineImages: S, recordCanvas: w, keepIframeSrcFn: I, newlyAddedElement: M, rootId: T }); case t.TEXT_NODE: return function (t, r) { var n; const { needsMask: i, maskTextFn: s, rootId: a } = r, c = t.parentNode && t.parentNode.tagName; let u = t.textContent; const l = "STYLE" === c || void 0, p = "SCRIPT" === c || void 0; if (l && u) { try { t.nextSibling || t.previousSibling || (null === (n = t.parentNode.sheet) || void 0 === n ? void 0 : n.cssRules) && (u = o(t.parentNode.sheet)); } catch (e) { console.warn(`Cannot get CSS styles from text's parentNode. Error: ${e}`, t); } u = k(u, x()); } p && (u = "SCRIPT_PLACEHOLDER"); !l && !p && u && i && (u = s ? s(u, t.parentElement) : u.replace(/[\S]/g, "*")); return { type: e.Text, textContent: u || "", isStyle: l, rootId: a }; }(t, { needsMask: f, maskTextFn: y, rootId: T }); case t.CDATA_SECTION_NODE: return { type: e.CDATA, textContent: "", rootId: T }; case t.COMMENT_NODE: return { type: e.Comment, textContent: t.textContent || "", rootId: T }; default: return !1; } } function N(e) { return null == e ? "" : e.toLowerCase(); } function A(t, o) { const { doc: i, mirror: s, blockClass: a, blockSelector: c, maskTextClass: u, maskTextSelector: l, skipChild: d = !1, inlineStylesheet: h = !0, maskInputOptions: f = {}, maskTextFn: m, maskInputFn: y, slimDOMOptions: v, dataURLOptions: b = {}, inlineImages: S = !1, recordCanvas: k = !1, onSerialize: w, onIframeLoad: I, iframeLoadTimeout: M = 5e3, onStylesheetLoad: C, stylesheetLoadTimeout: x = 5e3, keepIframeSrcFn: E = (() => !1), newlyAddedElement: O = !1 } = o; let { needsMask: T } = o, { preserveWhiteSpace: L = !0 } = o; if (!T && t.childNodes) { T = R(t, u, l, void 0 === T); } const q = D(t, { doc: i, mirror: s, blockClass: a, blockSelector: c, needsMask: T, inlineStylesheet: h, maskInputOptions: f, maskTextFn: m, maskInputFn: y, dataURLOptions: b, inlineImages: S, recordCanvas: k, keepIframeSrcFn: E, newlyAddedElement: O }); if (!q) return console.warn(t, "not serialized"), null; let F; F = s.hasNode(t) ? s.getId(t) : !function (t, r) { if (r.comment && t.type === e.Comment) return !0; if (t.type === e.Element) { if (r.script && ("script" === t.tagName || "link" === t.tagName && ("preload" === t.attributes.rel || "modulepreload" === t.attributes.rel) && "script" === t.attributes.as || "link" === t.tagName && "prefetch" === t.attributes.rel && "string" == typeof t.attributes.href && "js" === p(t.attributes.href))) return !0; if (r.headFavicon && ("link" === t.tagName && "shortcut icon" === t.attributes.rel || "meta" === t.tagName && (N(t.attributes.name).match(/^msapplication-tile(image|color)$/) || "application-name" === N(t.attributes.name) || "icon" === N(t.attributes.rel) || "apple-touch-icon" === N(t.attributes.rel) || "shortcut icon" === N(t.attributes.rel)))) return !0; if ("meta" === t.tagName) { if (r.headMetaDescKeywords && N(t.attributes.name).match(/^description|keywords$/)) return !0; if (r.headMetaSocial && (N(t.attributes.property).match(/^(og|twitter|fb):/) || N(t.attributes.name).match(/^(og|twitter):/) || "pinterest" === N(t.attributes.name))) return !0; if (r.headMetaRobots && ("robots" === N(t.attributes.name) || "googlebot" === N(t.attributes.name) || "bingbot" === N(t.attributes.name))) return !0; if (r.headMetaHttpEquiv && void 0 !== t.attributes["http-equiv"]) return !0; if (r.headMetaAuthorship && ("author" === N(t.attributes.name) || "generator" === N(t.attributes.name) || "framework" === N(t.attributes.name) || "publisher" === N(t.attributes.name) || "progid" === N(t.attributes.name) || N(t.attributes.property).match(/^article:/) || N(t.attributes.property).match(/^product:/))) return !0; if (r.headMetaVerification && ("google-site-verification" === N(t.attributes.name) || "yandex-verification" === N(t.attributes.name) || "csrf-token" === N(t.attributes.name) || "p:domain_verify" === N(t.attributes.name) || "verify-v1" === N(t.attributes.name) || "verification" === N(t.attributes.name) || "shopify-checkout-api-token" === N(t.attributes.name))) return !0; } } return !1; }(q, v) && (L || q.type !== e.Text || q.isStyle || q.textContent.replace(/^\s+|\s+$/gm, "").length) ? g() : _; const P = Object.assign(q, { id: F }); if (s.add(t, P), F === _) return null; w && w(t); let U = !d; if (P.type === e.Element) { U = U && !P.needBlock, delete P.needBlock; const e = t.shadowRoot; e && n(e) && (P.isShadowHost = !0); } if ((P.type === e.Document || P.type === e.Element) && U) { v.headWhitespace && P.type === e.Element && "head" === P.tagName && (L = !1); const r = { doc: i, mirror: s, blockClass: a, blockSelector: c, needsMask: T, maskTextClass: u, maskTextSelector: l, skipChild: d, inlineStylesheet: h, maskInputOptions: f, maskTextFn: m, maskInputFn: y, slimDOMOptions: v, dataURLOptions: b, inlineImages: S, recordCanvas: k, preserveWhiteSpace: L, onSerialize: w, onIframeLoad: I, iframeLoadTimeout: M, onStylesheetLoad: C, stylesheetLoadTimeout: x, keepIframeSrcFn: E }; if (P.type === e.Element && "textarea" === P.tagName && void 0 !== P.attributes.value); else for (const e of Array.from(t.childNodes)) { const t = A(e, r); t && P.childNodes.push(t); } if (function (e) { return e.nodeType === e.ELEMENT_NODE; }(t) && t.shadowRoot) for (const e of Array.from(t.shadowRoot.childNodes)) { const o = A(e, r); o && (n(t.shadowRoot) && (o.isShadow = !0), P.childNodes.push(o)); } } return t.parentNode && r(t.parentNode) && n(t.parentNode) && (P.isShadow = !0), P.type === e.Element && "iframe" === P.tagName && function (e, t, r) { const n = e.contentWindow; if (!n) return; let o, i = !1; try { o = n.document.readyState; } catch (e) { return; } if ("complete" !== o) { const n = setTimeout((() => { i || (t(), i = !0); }), r); return void e.addEventListener("load", (() => { clearTimeout(n), i = !0, t(); })); } const s = "about:blank"; if (n.location.href !== s || e.src === s || "" === e.src) return setTimeout(t, 0), e.addEventListener("load", t); e.addEventListener("load", t); }(t, (() => { const e = t.contentDocument; if (e && I) { const r = A(e, { doc: e, mirror: s, blockClass: a, blockSelector: c, needsMask: T, maskTextClass: u, maskTextSelector: l, skipChild: !1, inlineStylesheet: h, maskInputOptions: f, maskTextFn: m, maskInputFn: y, slimDOMOptions: v, dataURLOptions: b, inlineImages: S, recordCanvas: k, preserveWhiteSpace: L, onSerialize: w, onIframeLoad: I, iframeLoadTimeout: M, onStylesheetLoad: C, stylesheetLoadTimeout: x, keepIframeSrcFn: E }); r && I(t, r); } }), M), P.type === e.Element && "link" === P.tagName && "string" == typeof P.attributes.rel && ("stylesheet" === P.attributes.rel || "preload" === P.attributes.rel && "string" == typeof P.attributes.href && "css" === p(P.attributes.href)) && function (e, t, r) { let n, o = !1; try { n = e.sheet; } catch (e) { return; } if (n) return; const i = setTimeout((() => { o || (t(), o = !0); }), r); e.addEventListener("load", (() => { clearTimeout(i), o = !0, t(); })); }(t, (() => { if (C) { const e = A(t, { doc: i, mirror: s, blockClass: a, blockSelector: c, needsMask: T, maskTextClass: u, maskTextSelector: l, skipChild: !1, inlineStylesheet: h, maskInputOptions: f, maskTextFn: m, maskInputFn: y, slimDOMOptions: v, dataURLOptions: b, inlineImages: S, recordCanvas: k, preserveWhiteSpace: L, onSerialize: w, onIframeLoad: I, iframeLoadTimeout: M, onStylesheetLoad: C, stylesheetLoadTimeout: x, keepIframeSrcFn: E }); e && C(t, e); } }), x), P; } function L(e, t, r = document) { const n = { capture: !0, passive: !0 }; return r.addEventListener(e, t, n), () => r.removeEventListener(e, t, n); } var q = "Please stop import mirror directly. Instead of that,\r\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\r\nor you can use record.mirror to access the mirror instance during recording.", F = { map: {}, getId: () => (console.error(q), -1), getNode: () => (console.error(q), null), removeNodeFromMap() { console.error(q); }, has: () => (console.error(q), !1), reset() { console.error(q); } }; function P(e, t, r = {}) { let n = null, o = 0; return function (...i) { const s = Date.now(); o || !1 !== r.leading || (o = s); const a = t - (s - o), c = this; a <= 0 || a > t ? (n && (clearTimeout(n), n = null), o = s, e.apply(c, i)) : n || !1 === r.trailing || (n = setTimeout((() => { o = !1 === r.leading ? 0 : Date.now(), n = null, e.apply(c, i); }), a)); }; } function U(e, t, r, n, o = window) { const i = o.Object.getOwnPropertyDescriptor(e, t); return o.Object.defineProperty(e, t, n ? r : { set(e) { setTimeout((() => { r.set.call(this, e); }), 0), i && i.set && i.set.call(this, e); } }), () => U(e, t, i || {}, !0); } function j(e, t, r) { try { if (!(t in e)) return () => { }; const n = e[t], o = r(n); return "function" == typeof o && (o.prototype = o.prototype || {}, Object.defineProperties(o, { __rrweb_original__: { enumerable: !1, value: n } })), e[t] = o, () => { e[t] = n; }; } catch (e) { return () => { }; } } "undefined" != typeof window && window.Proxy && window.Reflect && (F = new Proxy(F, { get: (e, t, r) => ("map" === t && console.error(q), Reflect.get(e, t, r)) })); var B = Date.now; function $(e) { var t, r, n, o, i, s; const a = e.document; return { left: a.scrollingElement ? a.scrollingElement.scrollLeft : void 0 !== e.pageXOffset ? e.pageXOffset : (null == a ? void 0 : a.documentElement.scrollLeft) || (null === (r = null === (t = null == a ? void 0 : a.body) || void 0 === t ? void 0 : t.parentElement) || void 0 === r ? void 0 : r.scrollLeft) || (null === (n = null == a ? void 0 : a.body) || void 0 === n ? void 0 : n.scrollLeft) || 0, top: a.scrollingElement ? a.scrollingElement.scrollTop : void 0 !== e.pageYOffset ? e.pageYOffset : (null == a ? void 0 : a.documentElement.scrollTop) || (null === (i = null === (o = null == a ? void 0 : a.body) || void 0 === o ? void 0 : o.parentElement) || void 0 === i ? void 0 : i.scrollTop) || (null === (s = null == a ? void 0 : a.body) || void 0 === s ? void 0 : s.scrollTop) || 0 }; } function z() { return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight; } function W() { return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth; } function V(e) { if (!e) return null; return e.nodeType === e.ELEMENT_NODE ? e : e.parentElement; } function H(e, t, r, n) { if (!e) return !1; const o = V(e); if (!o) return !1; try { if ("string" == typeof t) { if (o.classList.contains(t)) return !0; if (n && null !== o.closest("." + t)) return !0; } else if (T(o, t, n)) return !0; } catch (e) { } if (r) { if (o.matches(r)) return !0; if (n && null !== o.closest(r)) return !0; } return !1; } function G(e, t) { return t.getId(e) === _; } function J(e, t) { if (r(e)) return !1; const n = t.getId(e); return !t.has(n) || (!e.parentNode || e.parentNode.nodeType !== e.DOCUMENT_NODE) && (!e.parentNode || J(e.parentNode, t)); } function Q(e) { return Boolean(e.changedTouches); } function K(e, t) { return Boolean("IFRAME" === e.nodeName && t.getMeta(e)); } function X(e, t) { return Boolean("LINK" === e.nodeName && e.nodeType === e.ELEMENT_NODE && e.getAttribute && "stylesheet" === e.getAttribute("rel") && t.getMeta(e)); } function Y(e) { return Boolean(null == e ? void 0 : e.shadowRoot); } /[1-9][0-9]{12}/.test(Date.now().toString()) || (B = () => (new Date).getTime()); var Z = class { constructor() { this.id = 1, this.styleIDMap = new WeakMap, this.idStyleMap = new Map; } getId(e) { var t; return null !== (t = this.styleIDMap.get(e)) && void 0 !== t ? t : -1; } has(e) { return this.styleIDMap.has(e); } add(e, t) { if (this.has(e)) return this.getId(e); let r; return r = void 0 === t ? this.id++ : t, this.styleIDMap.set(e, r), this.idStyleMap.set(r, e), r; } getStyle(e) { return this.idStyleMap.get(e) || null; } reset() { this.styleIDMap = new WeakMap, this.idStyleMap = new Map, this.id = 1; } generateId() { return this.id++; } }; function ee(e) { var t, r; let n = null; return (null === (r = null === (t = e.getRootNode) || void 0 === t ? void 0 : t.call(e)) || void 0 === r ? void 0 : r.nodeType) === Node.DOCUMENT_FRAGMENT_NODE && e.getRootNode().host && (n = e.getRootNode().host), n; } function te(e) { const t = e.ownerDocument; if (!t) return !1; const r = function (e) { let t, r = e; for (; t = ee(r);)r = t; return r; }(e); return t.contains(r); } function re(e) { const t = e.ownerDocument; return !!t && (t.contains(e) || te(e)); } var ne, oe, ie, se, ae, ce = ((ne = ce || {})[ne.DomContentLoaded = 0] = "DomContentLoaded", ne[ne.Load = 1] = "Load", ne[ne.FullSnapshot = 2] = "FullSnapshot", ne[ne.IncrementalSnapshot = 3] = "IncrementalSnapshot", ne[ne.Meta = 4] = "Meta", ne[ne.Custom = 5] = "Custom", ne[ne.Plugin = 6] = "Plugin", ne), ue = ((oe = ue || {})[oe.Mutation = 0] = "Mutation", oe[oe.MouseMove = 1] = "MouseMove", oe[oe.MouseInteraction = 2] = "MouseInteraction", oe[oe.Scroll = 3] = "Scroll", oe[oe.ViewportResize = 4] = "ViewportResize", oe[oe.Input = 5] = "Input", oe[oe.TouchMove = 6] = "TouchMove", oe[oe.MediaInteraction = 7] = "MediaInteraction", oe[oe.StyleSheetRule = 8] = "StyleSheetRule", oe[oe.CanvasMutation = 9] = "CanvasMutation", oe[oe.Font = 10] = "Font", oe[oe.Log = 11] = "Log", oe[oe.Drag = 12] = "Drag", oe[oe.StyleDeclaration = 13] = "StyleDeclaration", oe[oe.Selection = 14] = "Selection", oe[oe.AdoptedStyleSheet = 15] = "AdoptedStyleSheet", oe[oe.CustomElement = 16] = "CustomElement", oe), le = ((ie = le || {})[ie.MouseUp = 0] = "MouseUp", ie[ie.MouseDown = 1] = "MouseDown", ie[ie.Click = 2] = "Click", ie[ie.ContextMenu = 3] = "ContextMenu", ie[ie.DblClick = 4] = "DblClick", ie[ie.Focus = 5] = "Focus", ie[ie.Blur = 6] = "Blur", ie[ie.TouchStart = 7] = "TouchStart", ie[ie.TouchMove_Departed = 8] = "TouchMove_Departed", ie[ie.TouchEnd = 9] = "TouchEnd", ie[ie.TouchCancel = 10] = "TouchCancel", ie), pe = ((se = pe || {})[se.Mouse = 0] = "Mouse", se[se.Pen = 1] = "Pen", se[se.Touch = 2] = "Touch", se), de = ((ae = de || {})[ae["2D"] = 0] = "2D", ae[ae.WebGL = 1] = "WebGL", ae[ae.WebGL2 = 2] = "WebGL2", ae); function he(e) { return "__ln" in e; } var fe, me = class { constructor() { this.length = 0, this.head = null, this.tail = null; } get(e) { if (e >= this.length) throw new Error("Position outside of list range"); let t = this.head; for (let r = 0; r < e; r++)t = (null == t ? void 0 : t.next) || null; return t; } addNode(e) { const t = { value: e, previous: null, next: null }; if (e.__ln = t, e.previousSibling && he(e.previousSibling)) { const r = e.previousSibling.__ln.next; t.next = r, t.previous = e.previousSibling.__ln, e.previousSibling.__ln.next = t, r && (r.previous = t); } else if (e.nextSibling && he(e.nextSibling) && e.nextSibling.__ln.previous) { const r = e.nextSibling.__ln.previous; t.previous = r, t.next = e.nextSibling.__ln, e.nextSibling.__ln.previous = t, r && (r.next = t); } else this.head && (this.head.previous = t), t.next = this.head, this.head = t; null === t.next && (this.tail = t), this.length++; } removeNode(e) { const t = e.__ln; this.head && (t.previous ? (t.previous.next = t.next, t.next ? t.next.previous = t.previous : this.tail = t.previous) : (this.head = t.next, this.head ? this.head.previous = null : this.tail = null), e.__ln && delete e.__ln, this.length--); } }, _e = (e, t) => `${e}@${t}`, ge = class { constructor() { this.frozen = !1, this.locked = !1, this.texts = [], this.attributes = [], this.attributeMap = new WeakMap, this.removes = [], this.mapRemoves = [], this.movedMap = {}, this.addedSet = new Set, this.movedSet = new Set, this.droppedSet = new Set, this.processMutations = e => { e.forEach(this.processMutation), this.emit(); }, this.emit = () => { if (this.frozen || this.locked) return; const e = [], t = new Set, n = new me, o = e => { let t = e, r = _; for (; r === _;)t = t && t.nextSibling, r = t && this.mirror.getId(t); return r; }, i = i => { if (!i.parentNode || !re(i) || "TEXTAREA" === i.parentNode.tagName) return; const s = r(i.parentNode) ? this.mirror.getId(ee(i)) : this.mirror.getId(i.parentNode), a = o(i); if (-1 === s || -1 === a) return n.addNode(i); const c = A(i, { doc: this.doc, mirror: this.mirror, blockClass: this.blockClass, blockSelector: this.blockSelector, maskTextClass: this.maskTextClass, maskTextSelector: this.maskTextSelector, skipChild: !0, newlyAddedElement: !0, inlineStylesheet: this.inlineStylesheet, maskInputOptions: this.maskInputOptions, maskTextFn: this.maskTextFn, maskInputFn: this.maskInputFn, slimDOMOptions: this.slimDOMOptions, dataURLOptions: this.dataURLOptions, recordCanvas: this.recordCanvas, inlineImages: this.inlineImages, onSerialize: e => { K(e, this.mirror) && this.iframeManager.addIframe(e), X(e, this.mirror) && this.stylesheetManager.trackLinkElement(e), Y(i) && this.shadowDomManager.addShadowRoot(i.shadowRoot, this.doc); }, onIframeLoad: (e, t) => { this.iframeManager.attachIframe(e, t), this.shadowDomManager.observeAttachShadow(e); }, onStylesheetLoad: (e, t) => { this.stylesheetManager.attachLinkElement(e, t); } }); c && (e.push({ parentId: s, nextId: a, node: c }), t.add(c.id)); }; for (; this.mapRemoves.length;)this.mirror.removeNodeFromMap(this.mapRemoves.shift()); for (const e of this.movedSet) ve(this.removes, e, this.mirror) && !this.movedSet.has(e.parentNode) || i(e); for (const e of this.addedSet) Se(this.droppedSet, e) || ve(this.removes, e, this.mirror) ? Se(this.movedSet, e) ? i(e) : this.droppedSet.add(e) : i(e); let s = null; for (; n.length;) { let e = null; if (s) { const t = this.mirror.getId(s.value.parentNode), r = o(s.value); -1 !== t && -1 !== r && (e = s); } if (!e) { let t = n.tail; for (; t;) { const r = t; if (t = t.previous, r) { const t = this.mirror.getId(r.value.parentNode); if (-1 === o(r.value)) continue; if (-1 !== t) { e = r; break; } { const t = r.value; if (t.parentNode && t.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) { const n = t.parentNode.host; if (-1 !== this.mirror.getId(n)) { e = r; break; } } } } } } if (!e) { for (; n.head;)n.removeNode(n.head.value); break; } s = e.previous, n.removeNode(e.value), i(e.value); } const a = { texts: this.texts.map((e => { const t = e.node; return t.parentNode && "TEXTAREA" === t.parentNode.tagName && this.genTextAreaValueMutation(t.parentNode), { id: this.mirror.getId(t), value: e.value }; })).filter((e => !t.has(e.id))).filter((e => this.mirror.has(e.id))), attributes: this.attributes.map((e => { const { attributes: t } = e; if ("string" == typeof t.style) { const r = JSON.stringify(e.styleDiff), n = JSON.stringify(e._unchangedStyles); r.length < t.style.length && (r + n).split("var(").length === t.style.split("var(").length && (t.style = e.styleDiff); } return { id: this.mirror.getId(e.node), attributes: t }; })).filter((e => !t.has(e.id))).filter((e => this.mirror.has(e.id))), removes: this.removes, adds: e }; (a.texts.length || a.attributes.length || a.removes.length || a.adds.length) && (this.texts = [], this.attributes = [], this.attributeMap = new WeakMap, this.removes = [], this.addedSet = new Set, this.movedSet = new Set, this.droppedSet = new Set, this.movedMap = {}, this.mutationCb(a)); }, this.genTextAreaValueMutation = e => { let t = this.attributeMap.get(e); t || (t = { node: e, attributes: {}, styleDiff: {}, _unchangedStyles: {} }, this.attributes.push(t), this.attributeMap.set(e, t)), t.attributes.value = Array.from(e.childNodes, (e => e.textContent || "")).join(""); }, this.processMutation = e => { if (!G(e.target, this.mirror)) switch (e.type) { case "characterData": { const t = e.target.textContent; H(e.target, this.blockClass, this.blockSelector, !1) || t === e.oldValue || this.texts.push({ value: R(e.target, this.maskTextClass, this.maskTextSelector, !0) && t ? this.maskTextFn ? this.maskTextFn(t, V(e.target)) : t.replace(/[\S]/g, "*") : t, node: e.target }); break; } case "attributes": { const t = e.target; let r = e.attributeName, n = e.target.getAttribute(r); if ("value" === r) { const e = l(t); n = a({ element: t, maskInputOptions: this.maskInputOptions, tagName: t.tagName, type: e, value: n, maskInputFn: this.maskInputFn }); } if (H(e.target, this.blockClass, this.blockSelector, !1) || n === e.oldValue) return; let o = this.attributeMap.get(e.target); if ("IFRAME" === t.tagName && "src" === r && !this.keepIframeSrcFn(n)) { if (t.contentDocument) return; r = "rr_src"; } if (o || (o = { node: e.target, attributes: {}, styleDiff: {}, _unchangedStyles: {} }, this.attributes.push(o), this.attributeMap.set(e.target, o)), "type" === r && "INPUT" === t.tagName && "password" === (e.oldValue || "").toLowerCase() && t.setAttribute("data-rr-is-password", "true"), !O(t.tagName, r) && (o.attributes[r] = E(this.doc, c(t.tagName), c(r), n), "style" === r)) { if (!this.unattachedDoc) try { this.unattachedDoc = document.implementation.createHTMLDocument(); } catch (e) { this.unattachedDoc = this.doc; } const r = this.unattachedDoc.createElement("span"); e.oldValue && r.setAttribute("style", e.oldValue); for (const e of Array.from(t.style)) { const n = t.style.getPropertyValue(e), i = t.style.getPropertyPriority(e); n !== r.style.getPropertyValue(e) || i !== r.style.getPropertyPriority(e) ? o.styleDiff[e] = "" === i ? n : [n, i] : o._unchangedStyles[e] = [n, i]; } for (const e of Array.from(r.style)) "" === t.style.getPropertyValue(e) && (o.styleDiff[e] = !1); } break; } case "childList": if (H(e.target, this.blockClass, this.blockSelector, !0)) return; if ("TEXTAREA" === e.target.tagName) return void this.genTextAreaValueMutation(e.target); e.addedNodes.forEach((t => this.genAdds(t, e.target))), e.removedNodes.forEach((t => { const o = this.mirror.getId(t), i = r(e.target) ? this.mirror.getId(e.target.host) : this.mirror.getId(e.target); H(e.target, this.blockClass, this.blockSelector, !1) || G(t, this.mirror) || !function (e, t) { return -1 !== t.getId(e); }(t, this.mirror) || (this.addedSet.has(t) ? (ye(this.addedSet, t), this.droppedSet.add(t)) : this.addedSet.has(e.target) && -1 === o || J(e.target, this.mirror) || (this.movedSet.has(t) && this.movedMap[_e(o, i)] ? ye(this.movedSet, t) : this.removes.push({ parentId: i, id: o, isShadow: !(!r(e.target) || !n(e.target)) || void 0 })), this.mapRemoves.push(t)); })); } }, this.genAdds = (e, t) => { if (!this.processedNodeManager.inOtherBuffer(e, this) && !this.addedSet.has(e) && !this.movedSet.has(e)) { if (this.mirror.hasNode(e)) { if (G(e, this.mirror)) return; this.movedSet.add(e); let r = null; t && this.mirror.hasNode(t) && (r = this.mirror.getId(t)), r && -1 !== r && (this.movedMap[_e(this.mirror.getId(e), r)] = !0); } else this.addedSet.add(e), this.droppedSet.delete(e); H(e, this.blockClass, this.blockSelector, !1) || (e.childNodes.forEach((e => this.genAdds(e))), Y(e) && e.shadowRoot.childNodes.forEach((t => { this.processedNodeManager.add(t, this), this.genAdds(t, e); }))); } }; } init(e) { ["mutationCb", "blockClass", "blockSelector", "maskTextClass", "maskTextSelector", "inlineStylesheet", "maskInputOptions", "maskTextFn", "maskInputFn", "keepIframeSrcFn", "recordCanvas", "inlineImages", "slimDOMOptions", "dataURLOptions", "doc", "mirror", "iframeManager", "stylesheetManager", "shadowDomManager", "canvasManager", "processedNodeManager"].forEach((t => { this[t] = e[t]; })); } freeze() { this.frozen = !0, this.canvasManager.freeze(); } unfreeze() { this.frozen = !1, this.canvasManager.unfreeze(), this.emit(); } isFrozen() { return this.frozen; } lock() { this.locked = !0, this.canvasManager.lock(); } unlock() { this.locked = !1, this.canvasManager.unlock(), this.emit(); } reset() { this.shadowDomManager.reset(), this.canvasManager.reset(); } }; function ye(e, t) { e.delete(t), t.childNodes.forEach((t => ye(e, t))); } function ve(e, t, r) { return 0 !== e.length && be(e, t, r); } function be(e, t, r) { const { parentNode: n } = t; if (!n) return !1; const o = r.getId(n); return !!e.some((e => e.id === o)) || be(e, n, r); } function Se(e, t) { return 0 !== e.size && ke(e, t); } function ke(e, t) { const { parentNode: r } = t; return !!r && (!!e.has(r) || ke(e, r)); } var we = e => { if (!fe) return e; return (...t) => { try { return e(...t); } catch (e) { if (fe && !0 === fe(e)) return; throw e; } }; }, Ie = []; function Me(e) { try { if ("composedPath" in e) { const t = e.composedPath(); if (t.length) return t[0]; } else if ("path" in e && e.path.length) return e.path[0]; } catch (e) { } return e && e.target; } function Ce(e, t) { var r, n; const o = new ge; Ie.push(o), o.init(e); let i = window.MutationObserver || window.__rrMutationObserver; const s = null === (n = null === (r = null === window || void 0 === window ? void 0 : window.Zone) || void 0 === r ? void 0 : r.__symbol__) || void 0 === n ? void 0 : n.call(r, "MutationObserver"); s && window[s] && (i = window[s]); const a = new i(we(o.processMutations.bind(o))); return a.observe(t, { attributes: !0, attributeOldValue: !0, characterData: !0, characterDataOldValue: !0, childList: !0, subtree: !0 }), a; } function xe({ mouseInteractionCb: e, doc: t, mirror: r, blockClass: n, blockSelector: o, sampling: i }) { if (!1 === i.mouseInteraction) return () => { }; const s = !0 === i.mouseInteraction || void 0 === i.mouseInteraction ? {} : i.mouseInteraction, a = []; let u = null; return Object.keys(le).filter((e => Number.isNaN(Number(e)) && !e.endsWith("_Departed") && !1 !== s[e])).forEach((i => { let s = c(i); const l = (t => i => { const s = Me(i); if (H(s, n, o, !0)) return; let a = null, c = t; if ("pointerType" in i) { switch (i.pointerType) { case "mouse": a = pe.Mouse; break; case "touch": a = pe.Touch; break; case "pen": a = pe.Pen; }a === pe.Touch ? le[t] === le.MouseDown ? c = "TouchStart" : le[t] === le.MouseUp && (c = "TouchEnd") : pe.Pen; } else Q(i) && (a = pe.Touch); null !== a ? (u = a, (c.startsWith("Touch") && a === pe.Touch || c.startsWith("Mouse") && a === pe.Mouse) && (a = null)) : le[t] === le.Click && (a = u, u = null); const l = Q(i) ? i.changedTouches[0] : i; if (!l) return; const p = r.getId(s), { clientX: d, clientY: h } = l; we(e)(Object.assign({ type: le[c], id: p, x: d, y: h }, null !== a && { pointerType: a })); })(i); if (window.PointerEvent) switch (le[i]) { case le.MouseDown: case le.MouseUp: s = s.replace("mouse", "pointer"); break; case le.TouchStart: case le.TouchEnd: return; }a.push(L(s, l, t)); })), we((() => { a.forEach((e => e())); })); } function Ee({ scrollCb: e, doc: t, mirror: r, blockClass: n, blockSelector: o, sampling: i }) { return L("scroll", we(P(we((i => { const s = Me(i); if (!s || H(s, n, o, !0)) return; const a = r.getId(s); if (s === t && t.defaultView) { const r = $(t.defaultView); e({ id: a, x: r.left, y: r.top }); } else e({ id: a, x: s.scrollLeft, y: s.scrollTop }); })), i.scroll || 100)), t); } var Oe = ["INPUT", "TEXTAREA", "SELECT"], Te = new WeakMap; function Re(e) { return function (e, t) { if (Le("CSSGroupingRule") && e.parentRule instanceof CSSGroupingRule || Le("CSSMediaRule") && e.parentRule instanceof CSSMediaRule || Le("CSSSupportsRule") && e.parentRule instanceof CSSSupportsRule || Le("CSSConditionRule") && e.parentRule instanceof CSSConditionRule) { const r = Array.from(e.parentRule.cssRules).indexOf(e); t.unshift(r); } else if (e.parentStyleSheet) { const r = Array.from(e.parentStyleSheet.cssRules).indexOf(e); t.unshift(r); } return t; }(e, []); } function De(e, t, r) { let n, o; return e ? (e.ownerNode ? n = t.getId(e.ownerNode) : o = r.getId(e), { styleId: o, id: n }) : {}; } function Ne({ mirror: e, stylesheetManager: t }, r) { var n, o, i; let s = null; s = "#document" === r.nodeName ? e.getId(r) : e.getId(r.host); const a = "#document" === r.nodeName ? null === (n = r.defaultView) || void 0 === n ? void 0 : n.Document : null === (i = null === (o = r.ownerDocument) || void 0 === o ? void 0 : o.defaultView) || void 0 === i ? void 0 : i.ShadowRoot, c = (null == a ? void 0 : a.prototype) ? Object.getOwnPropertyDescriptor(null == a ? void 0 : a.prototype, "adoptedStyleSheets") : void 0; return null !== s && -1 !== s && a && c ? (Object.defineProperty(r, "adoptedStyleSheets", { configurable: c.configurable, enumerable: c.enumerable, get() { var e; return null === (e = c.get) || void 0 === e ? void 0 : e.call(this); }, set(e) { var r; const n = null === (r = c.set) || void 0 === r ? void 0 : r.call(this, e); if (null !== s && -1 !== s) try { t.adoptStyleSheets(e, s); } catch (e) { } return n; } }), we((() => { Object.defineProperty(r, "adoptedStyleSheets", { configurable: c.configurable, enumerable: c.enumerable, get: c.get, set: c.set }); }))) : () => { }; } function Ae(e, t = {}) { const r = e.doc.defaultView; if (!r) return () => { }; let n; !function (e, t) { const { mutationCb: r, mousemoveCb: n, mouseInteractionCb: o, scrollCb: i, viewportResizeCb: s, inputCb: a, mediaInteractionCb: c, styleSheetRuleCb: u, styleDeclarationCb: l, canvasMutationCb: p, fontCb: d, selectionCb: h, customElementCb: f } = e; e.mutationCb = (...e) => { t.mutation && t.mutation(...e), r(...e); }, e.mousemoveCb = (...e) => { t.mousemove && t.mousemove(...e), n(...e); }, e.mouseInteractionCb = (...e) => { t.mouseInteraction && t.mouseInteraction(...e), o(...e); }, e.scrollCb = (...e) => { t.scroll && t.scroll(...e), i(...e); }, e.viewportResizeCb = (...e) => { t.viewportResize && t.viewportResize(...e), s(...e); }, e.inputCb = (...e) => { t.input && t.input(...e), a(...e); }, e.mediaInteractionCb = (...e) => { t.mediaInteaction && t.mediaInteaction(...e), c(...e); }, e.styleSheetRuleCb = (...e) => { t.styleSheetRule && t.styleSheetRule(...e), u(...e); }, e.styleDeclarationCb = (...e) => { t.styleDeclaration && t.styleDeclaration(...e), l(...e); }, e.canvasMutationCb = (...e) => { t.canvasMutation && t.canvasMutation(...e), p(...e); }, e.fontCb = (...e) => { t.font && t.font(...e), d(...e); }, e.selectionCb = (...e) => { t.selection && t.selection(...e), h(...e); }, e.customElementCb = (...e) => { t.customElement && t.customElement(...e), f(...e); }; }(e, t), e.recordDOM && (n = Ce(e, e.doc)); const o = function ({ mousemoveCb: e, sampling: t, doc: r, mirror: n }) { if (!1 === t.mousemove) return () => { }; const o = "number" == typeof t.mousemove ? t.mousemove : 50, i = "number" == typeof t.mousemoveCallback ? t.mousemoveCallback : 500; let s, a = []; const c = P(we((t => { const r = Date.now() - s; e(a.map((e => (e.timeOffset -= r, e))), t), a = [], s = null; })), i), u = we(P(we((e => { const t = Me(e), { clientX: r, clientY: o } = Q(e) ? e.changedTouches[0] : e; s || (s = B()), a.push({ x: r, y: o, id: n.getId(t), timeOffset: B() - s }), c("undefined" != typeof DragEvent && e instanceof DragEvent ? ue.Drag : e instanceof MouseEvent ? ue.MouseMove : ue.TouchMove); })), o, { trailing: !1 })), l = [L("mousemove", u, r), L("touchmove", u, r), L("drag", u, r)]; return we((() => { l.forEach((e => e())); })); }(e), i = xe(e), s = Ee(e), c = function ({ viewportResizeCb: e }, { win: t }) { let r = -1, n = -1; return L("resize", we(P(we((() => { const t = z(), o = W(); r === t && n === o || (e({ width: Number(o), height: Number(t) }), r = t, n = o); })), 200)), t); }(e, { win: r }), u = function ({ inputCb: e, doc: t, mirror: r, blockClass: n, blockSelector: o, ignoreClass: i, ignoreSelector: s, maskInputOptions: c, maskInputFn: u, sampling: p, userTriggeredOnInput: d }) { function h(e) { let r = Me(e); const p = e.isTrusted, h = r && r.tagName; if (r && "OPTION" === h && (r = r.parentElement), !r || !h || Oe.indexOf(h) < 0 || H(r, n, o, !0)) return; if (r.classList.contains(i) || s && r.matches(s)) return; let m = r.value, _ = !1; const g = l(r) || ""; "radio" === g || "checkbox" === g ? _ = r.checked : (c[h.toLowerCase()] || c[g]) && (m = a({ element: r, maskInputOptions: c, tagName: h, type: g, value: m, maskInputFn: u })), f(r, d ? { text: m, isChecked: _, userTriggered: p } : { text: m, isChecked: _ }); const y = r.name; "radio" === g && y && _ && t.querySelectorAll(`input[type="radio"][name="${y}"]`).forEach((e => { if (e !== r) { const t = e.value; f(e, d ? { text: t, isChecked: !_, userTriggered: !1 } : { text: t, isChecked: !_ }); } })); } function f(t, n) { const o = Te.get(t); if (!o || o.text !== n.text || o.isChecked !== n.isChecked) { Te.set(t, n); const o = r.getId(t); we(e)(Object.assign(Object.assign({}, n), { id: o })); } } const m = ("last" === p.input ? ["change"] : ["input", "change"]).map((e => L(e, we(h), t))), _ = t.defaultView; if (!_) return () => { m.forEach((e => e())); }; const g = _.Object.getOwnPropertyDescriptor(_.HTMLInputElement.prototype, "value"), y = [[_.HTMLInputElement.prototype, "value"], [_.HTMLInputElement.prototype, "checked"], [_.HTMLSelectElement.prototype, "value"], [_.HTMLTextAreaElement.prototype, "value"], [_.HTMLSelectElement.prototype, "selectedIndex"], [_.HTMLOptionElement.prototype, "selected"]]; return g && g.set && m.push(...y.map((e => U(e[0], e[1], { set() { we(h)({ target: this, isTrusted: !1 }); } }, !1, _)))), we((() => { m.forEach((e => e())); })); }(e), p = function ({ mediaInteractionCb: e, blockClass: t, blockSelector: r, mirror: n, sampling: o, doc: i }) { const s = we((i => P(we((o => { const s = Me(o); if (!s || H(s, t, r, !0)) return; const { currentTime: a, volume: c, muted: u, playbackRate: l, loop: p } = s; e({ type: i, id: n.getId(s), currentTime: a, volume: c, muted: u, playbackRate: l, loop: p }); })), o.media || 500))), a = [L("play", s(0), i), L("pause", s(1), i), L("seeked", s(2), i), L("volumechange", s(3), i), L("ratechange", s(4), i)]; return we((() => { a.forEach((e => e())); })); }(e); let d = () => { }, h = () => { }, f = () => { }, m = () => { }; e.recordDOM && (d = function ({ styleSheetRuleCb: e, mirror: t, stylesheetManager: r }, { win: n }) { if (!n.CSSStyleSheet || !n.CSSStyleSheet.prototype) return () => { }; const o = n.CSSStyleSheet.prototype.insertRule; n.CSSStyleSheet.prototype.insertRule = new Proxy(o, { apply: we(((n, o, i) => { const [s, a] = i, { id: c, styleId: u } = De(o, t, r.styleMirror); return (c && -1 !== c || u && -1 !== u) && e({ id: c, styleId: u, adds: [{ rule: s, index: a }] }), n.apply(o, i); })) }); const i = n.CSSStyleSheet.prototype.deleteRule; let s, a; n.CSSStyleSheet.prototype.deleteRule = new Proxy(i, { apply: we(((n, o, i) => { const [s] = i, { id: a, styleId: c } = De(o, t, r.styleMirror); return (a && -1 !== a || c && -1 !== c) && e({ id: a, styleId: c, removes: [{ index: s }] }), n.apply(o, i); })) }), n.CSSStyleSheet.prototype.replace && (s = n.CSSStyleSheet.prototype.replace, n.CSSStyleSheet.prototype.replace = new Proxy(s, { apply: we(((n, o, i) => { const [s] = i, { id: a, styleId: c } = De(o, t, r.styleMirror); return (a && -1 !== a || c && -1 !== c) && e({ id: a, styleId: c, replace: s }), n.apply(o, i); })) })), n.CSSStyleSheet.prototype.replaceSync && (a = n.CSSStyleSheet.prototype.replaceSync, n.CSSStyleSheet.prototype.replaceSync = new Proxy(a, { apply: we(((n, o, i) => { const [s] = i, { id: a, styleId: c } = De(o, t, r.styleMirror); return (a && -1 !== a || c && -1 !== c) && e({ id: a, styleId: c, replaceSync: s }), n.apply(o, i); })) })); const c = {}; qe("CSSGroupingRule") ? c.CSSGroupingRule = n.CSSGroupingRule : (qe("CSSMediaRule") && (c.CSSMediaRule = n.CSSMediaRule), qe("CSSConditionRule") && (c.CSSConditionRule = n.CSSConditionRule), qe("CSSSupportsRule") && (c.CSSSupportsRule = n.CSSSupportsRule)); const u = {}; return Object.entries(c).forEach((([n, o]) => { u[n] = { insertRule: o.prototype.insertRule, deleteRule: o.prototype.deleteRule }, o.prototype.insertRule = new Proxy(u[n].insertRule, { apply: we(((n, o, i) => { const [s, a] = i, { id: c, styleId: u } = De(o.parentStyleSheet, t, r.styleMirror); return (c && -1 !== c || u && -1 !== u) && e({ id: c, styleId: u, adds: [{ rule: s, index: [...Re(o), a || 0] }] }), n.apply(o, i); })) }), o.prototype.deleteRule = new Proxy(u[n].deleteRule, { apply: we(((n, o, i) => { const [s] = i, { id: a, styleId: c } = De(o.parentStyleSheet, t, r.styleMirror); return (a && -1 !== a || c && -1 !== c) && e({ id: a, styleId: c, removes: [{ index: [...Re(o), s] }] }), n.apply(o, i); })) }); })), we((() => { n.CSSStyleSheet.prototype.insertRule = o, n.CSSStyleSheet.prototype.deleteRule = i, s && (n.CSSStyleSheet.prototype.replace = s), a && (n.CSSStyleSheet.prototype.replaceSync = a), Object.entries(c).forEach((([e, t]) => { t.prototype.insertRule = u[e].insertRule, t.prototype.deleteRule = u[e].deleteRule; })); })); }(e, { win: r }), h = Ne(e, e.doc), f = function ({ styleDeclarationCb: e, mirror: t, ignoreCSSAttributes: r, stylesheetManager: n }, { win: o }) { const i = o.CSSStyleDeclaration.prototype.setProperty; o.CSSStyleDeclaration.prototype.setProperty = new Proxy(i, { apply: we(((o, s, a) => { var c; const [u, l, p] = a; if (r.has(u)) return i.apply(s, [u, l, p]); const { id: d, styleId: h } = De(null === (c = s.parentRule) || void 0 === c ? void 0 : c.parentStyleSheet, t, n.styleMirror); return (d && -1 !== d || h && -1 !== h) && e({ id: d, styleId: h, set: { property: u, value: l, priority: p }, index: Re(s.parentRule) }), o.apply(s, a); })) }); const s = o.CSSStyleDeclaration.prototype.removeProperty; return o.CSSStyleDeclaration.prototype.removeProperty = new Proxy(s, { apply: we(((o, i, a) => { var c; const [u] = a; if (r.has(u)) return s.apply(i, [u]); const { id: l, styleId: p } = De(null === (c = i.parentRule) || void 0 === c ? void 0 : c.parentStyleSheet, t, n.styleMirror); return (l && -1 !== l || p && -1 !== p) && e({ id: l, styleId: p, remove: { property: u }, index: Re(i.parentRule) }), o.apply(i, a); })) }), we((() => { o.CSSStyleDeclaration.prototype.setProperty = i, o.CSSStyleDeclaration.prototype.removeProperty = s; })); }(e, { win: r }), e.collectFonts && (m = function ({ fontCb: e, doc: t }) { const r = t.defaultView; if (!r) return () => { }; const n = [], o = new WeakMap, i = r.FontFace; r.FontFace = function (e, t, r) { const n = new i(e, t, r); return o.set(n, { family: e, buffer: "string" != typeof t, descriptors: r, fontSource: "string" == typeof t ? t : JSON.stringify(Array.from(new Uint8Array(t))) }), n; }; const s = j(t.fonts, "add", (function (t) { return function (r) { return setTimeout(we((() => { const t = o.get(r); t && (e(t), o.delete(r)); })), 0), t.apply(this, [r]); }; })); return n.push((() => { r.FontFace = i; })), n.push(s), we((() => { n.forEach((e => e())); })); }(e))); const _ = function (e) { const { doc: t, mirror: r, blockClass: n, blockSelector: o, selectionCb: i } = e; let s = !0; const a = we((() => { const e = t.getSelection(); if (!e || s && (null == e ? void 0 : e.isCollapsed)) return; s = e.isCollapsed || !1; const a = [], c = e.rangeCount || 0; for (let t = 0; t < c; t++) { const i = e.getRangeAt(t), { startContainer: s, startOffset: c, endContainer: u, endOffset: l } = i; H(s, n, o, !0) || H(u, n, o, !0) || a.push({ start: r.getId(s), startOffset: c, end: r.getId(u), endOffset: l }); } i({ ranges: a }); })); return a(), L("selectionchange", a); }(e), g = function ({ doc: e, customElementCb: t }) { const r = e.defaultView; return r && r.customElements ? j(r.customElements, "define", (function (e) { return function (r, n, o) { try { t({ define: { name: r } }); } catch (e) { console.warn(`Custom element callback failed for ${r}`); } return e.apply(this, [r, n, o]); }; })) : () => { }; }(e), y = []; for (const t of e.plugins) y.push(t.observer(t.callback, r, t.options)); return we((() => { Ie.forEach((e => e.reset())), null == n || n.disconnect(), o(), i(), s(), c(), u(), p(), d(), h(), f(), m(), _(), g(), y.forEach((e => e())); })); } function Le(e) { return void 0 !== window[e]; } function qe(e) { return Boolean(void 0 !== window[e] && window[e].prototype && "insertRule" in window[e].prototype && "deleteRule" in window[e].prototype); } var Fe = class { constructor(e) { this.generateIdFn = e, this.iframeIdToRemoteIdMap = new WeakMap, this.iframeRemoteIdToIdMap = new WeakMap; } getId(e, t, r, n) { const o = r || this.getIdToRemoteIdMap(e), i = n || this.getRemoteIdToIdMap(e); let s = o.get(t); return s || (s = this.generateIdFn(), o.set(t, s), i.set(s, t)), s; } getIds(e, t) { const r = this.getIdToRemoteIdMap(e), n = this.getRemoteIdToIdMap(e); return t.map((t => this.getId(e, t, r, n))); } getRemoteId(e, t, r) { const n = r || this.getRemoteIdToIdMap(e); if ("number" != typeof t) return t; const o = n.get(t); return o || -1; } getRemoteIds(e, t) { const r = this.getRemoteIdToIdMap(e); return t.map((t => this.getRemoteId(e, t, r))); } reset(e) { if (!e) return this.iframeIdToRemoteIdMap = new WeakMap, void (this.iframeRemoteIdToIdMap = new WeakMap); this.iframeIdToRemoteIdMap.delete(e), this.iframeRemoteIdToIdMap.delete(e); } getIdToRemoteIdMap(e) { let t = this.iframeIdToRemoteIdMap.get(e); return t || (t = new Map, this.iframeIdToRemoteIdMap.set(e, t)), t; } getRemoteIdToIdMap(e) { let t = this.iframeRemoteIdToIdMap.get(e); return t || (t = new Map, this.iframeRemoteIdToIdMap.set(e, t)), t; } }, Pe = class { constructor(e) { this.iframes = new WeakMap, this.crossOriginIframeMap = new WeakMap, this.crossOriginIframeMirror = new Fe(g), this.crossOriginIframeRootIdMap = new WeakMap, this.mutationCb = e.mutationCb, this.wrappedEmit = e.wrappedEmit, this.stylesheetManager = e.stylesheetManager, this.recordCrossOriginIframes = e.recordCrossOriginIframes, this.crossOriginIframeStyleMirror = new Fe(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror)), this.mirror = e.mirror, this.recordCrossOriginIframes && window.addEventListener("message", this.handleMessage.bind(this)); } addIframe(e) { this.iframes.set(e, !0), e.contentWindow && this.crossOriginIframeMap.set(e.contentWindow, e); } addLoadListener(e) { this.loadListener = e; } attachIframe(e, t) { var r; this.mutationCb({ adds: [{ parentId: this.mirror.getId(e), nextId: null, node: t }], removes: [], texts: [], attributes: [], isAttachIframe: !0 }), null === (r = this.loadListener) || void 0 === r || r.call(this, e), e.contentDocument && e.contentDocument.adoptedStyleSheets && e.contentDocument.adoptedStyleSheets.length > 0 && this.stylesheetManager.adoptStyleSheets(e.contentDocument.adoptedStyleSheets, this.mirror.getId(e.contentDocument)); } handleMessage(e) { const t = e; if ("rrweb" !== t.data.type || t.origin !== t.data.origin) return; if (!e.source) return; const r = this.crossOriginIframeMap.get(e.source); if (!r) return; const n = this.transformCrossOriginEvent(r, t.data.event); n && this.wrappedEmit(n, t.data.isCheckout); } transformCrossOriginEvent(e, t) { var r; switch (t.type) { case ce.FullSnapshot: { this.crossOriginIframeMirror.reset(e), this.crossOriginIframeStyleMirror.reset(e), this.replaceIdOnNode(t.data.node, e); const r = t.data.node.id; return this.crossOriginIframeRootIdMap.set(e, r), this.patchRootIdOnNode(t.data.node, r), { timestamp: t.timestamp, type: ce.IncrementalSnapshot, data: { source: ue.Mutation, adds: [{ parentId: this.mirror.getId(e), nextId: null, node: t.data.node }], removes: [], texts: [], attributes: [], isAttachIframe: !0 } }; } case ce.Meta: case ce.Load: case ce.DomContentLoaded: return !1; case ce.Plugin: return t; case ce.Custom: return this.replaceIds(t.data.payload, e, ["id", "parentId", "previousId", "nextId"]), t; case ce.IncrementalSnapshot: switch (t.data.source) { case ue.Mutation: return t.data.adds.forEach((t => { this.replaceIds(t, e, ["parentId", "nextId", "previousId"]), this.replaceIdOnNode(t.node, e); const r = this.crossOriginIframeRootIdMap.get(e); r && this.patchRootIdOnNode(t.node, r); })), t.data.removes.forEach((t => { this.replaceIds(t, e, ["parentId", "id"]); })), t.data.attributes.forEach((t => { this.replaceIds(t, e, ["id"]); })), t.data.texts.forEach((t => { this.replaceIds(t, e, ["id"]); })), t; case ue.Drag: case ue.TouchMove: case ue.MouseMove: return t.data.positions.forEach((t => { this.replaceIds(t, e, ["id"]); })), t; case ue.ViewportResize: return !1; case ue.MediaInteraction: case ue.MouseInteraction: case ue.Scroll: case ue.CanvasMutation: case ue.Input: return this.replaceIds(t.data, e, ["id"]), t; case ue.StyleSheetRule: case ue.StyleDeclaration: return this.replaceIds(t.data, e, ["id"]), this.replaceStyleIds(t.data, e, ["styleId"]), t; case ue.Font: return t; case ue.Selection: return t.data.ranges.forEach((t => { this.replaceIds(t, e, ["start", "end"]); })), t; case ue.AdoptedStyleSheet: return this.replaceIds(t.data, e, ["id"]), this.replaceStyleIds(t.data, e, ["styleIds"]), null === (r = t.data.styles) || void 0 === r || r.forEach((t => { this.replaceStyleIds(t, e, ["styleId"]); })), t; } }return !1; } replace(e, t, r, n) { for (const o of n) (Array.isArray(t[o]) || "number" == typeof t[o]) && (Array.isArray(t[o]) ? t[o] = e.getIds(r, t[o]) : t[o] = e.getId(r, t[o])); return t; } replaceIds(e, t, r) { return this.replace(this.crossOriginIframeMirror, e, t, r); } replaceStyleIds(e, t, r) { return this.replace(this.crossOriginIframeStyleMirror, e, t, r); } replaceIdOnNode(e, t) { this.replaceIds(e, t, ["id", "rootId"]), "childNodes" in e && e.childNodes.forEach((e => { this.replaceIdOnNode(e, t); })); } patchRootIdOnNode(t, r) { t.type === e.Document || t.rootId || (t.rootId = r), "childNodes" in t && t.childNodes.forEach((e => { this.patchRootIdOnNode(e, r); })); } }, Ue = class { constructor(e) { this.shadowDoms = new WeakSet, this.restoreHandlers = [], this.mutationCb = e.mutationCb, this.scrollCb = e.scrollCb, this.bypassOptions = e.bypassOptions, this.mirror = e.mirror, this.init(); } init() { this.reset(), this.patchAttachShadow(Element, document); } addShadowRoot(e, t) { if (!n(e)) return; if (this.shadowDoms.has(e)) return; this.shadowDoms.add(e); const r = Ce(Object.assign(Object.assign({}, this.bypassOptions), { doc: t, mutationCb: this.mutationCb, mirror: this.mirror, shadowDomManager: this }), e); this.restoreHandlers.push((() => r.disconnect())), this.restoreHandlers.push(Ee(Object.assign(Object.assign({}, this.bypassOptions), { scrollCb: this.scrollCb, doc: e, mirror: this.mirror }))), setTimeout((() => { e.adoptedStyleSheets && e.adoptedStyleSheets.length > 0 && this.bypassOptions.stylesheetManager.adoptStyleSheets(e.adoptedStyleSheets, this.mirror.getId(e.host)), this.restoreHandlers.push(Ne({ mirror: this.mirror, stylesheetManager: this.bypassOptions.stylesheetManager }, e)); }), 0); } observeAttachShadow(e) { e.contentWindow && e.contentDocument && this.patchAttachShadow(e.contentWindow.Element, e.contentDocument); } patchAttachShadow(e, t) { const r = this; this.restoreHandlers.push(j(e.prototype, "attachShadow", (function (e) { return function (n) { const o = e.call(this, n); return this.shadowRoot && re(this) && r.addShadowRoot(this.shadowRoot, t), o; }; }))); } reset() { this.restoreHandlers.forEach((e => { try { e(); } catch (e) { } })), this.restoreHandlers = [], this.shadowDoms = new WeakSet; } }; function je(e, t, r, n) { return new (r || (r = Promise))((function (o, i) { function s(e) { try { c(n.next(e)); } catch (e) { i(e); } } function a(e) { try { c(n.throw(e)); } catch (e) { i(e); } } function c(e) { var t; e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r((function (e) { e(t); }))).then(s, a); } c((n = n.apply(e, t || [])).next()); })); } var Be, $e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ze = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256); for (Be = 0; Be < 64; Be++)ze[$e.charCodeAt(Be)] = Be; var We = new Map; var Ve = (e, t, r) => { if (!e || !Je(e, t) && "object" != typeof e) return; const n = function (e, t) { let r = We.get(e); return r || (r = new Map, We.set(e, r)), r.has(t) || r.set(t, []), r.get(t); }(r, e.constructor.name); let o = n.indexOf(e); return -1 === o && (o = n.length, n.push(e)), o; }; function He(e, t, r) { if (e instanceof Array) return e.map((e => He(e, t, r))); if (null === e) return e; if (e instanceof Float32Array || e instanceof Float64Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Uint8Array || e instanceof Uint16Array || e instanceof Int16Array || e instanceof Int8Array || e instanceof Uint8ClampedArray) { return { rr_type: e.constructor.name, args: [Object.values(e)] }; } if (e instanceof ArrayBuffer) { const t = e.constructor.name, r = function (e) { var t, r = new Uint8Array(e), n = r.length, o = ""; for (t = 0; t < n; t += 3)o += $e[r[t] >> 2], o += $e[(3 & r[t]) << 4 | r[t + 1] >> 4], o += $e[(15 & r[t + 1]) << 2 | r[t + 2] >> 6], o += $e[63 & r[t + 2]]; return n % 3 == 2 ? o = o.substring(0, o.length - 1) + "=" : n % 3 == 1 && (o = o.substring(0, o.length - 2) + "=="), o; }(e); return { rr_type: t, base64: r }; } if (e instanceof DataView) { return { rr_type: e.constructor.name, args: [He(e.buffer, t, r), e.byteOffset, e.byteLength] }; } if (e instanceof HTMLImageElement) { const t = e.constructor.name, { src: r } = e; return { rr_type: t, src: r }; } if (e instanceof HTMLCanvasElement) { return { rr_type: "HTMLImageElement", src: e.toDataURL() }; } if (e instanceof ImageData) { return { rr_type: e.constructor.name, args: [He(e.data, t, r), e.width, e.height] }; } if (Je(e, t) || "object" == typeof e) { return { rr_type: e.constructor.name, index: Ve(e, t, r) }; } return e; } var Ge = (e, t, r) => e.map((e => He(e, t, r))), Je = (e, t) => { const r = ["WebGLActiveInfo", "WebGLBuffer", "WebGLFramebuffer", "WebGLProgram", "WebGLRenderbuffer", "WebGLShader", "WebGLShaderPrecisionFormat", "WebGLTexture", "WebGLUniformLocation", "WebGLVertexArrayObject", "WebGLVertexArrayObjectOES"].filter((e => "function" == typeof t[e])); return Boolean(r.find((r => e instanceof t[r]))); }; function Qe(e, t, r, n) { const o = []; try { const i = j(e.HTMLCanvasElement.prototype, "getContext", (function (e) { return function (o, ...i) { if (!H(this, t, r, !0)) { const e = function (e) { return "experimental-webgl" === e ? "webgl" : e; }(o); if ("__context" in this || (this.__context = e), n && ["webgl", "webgl2"].includes(e)) if (i[0] && "object" == typeof i[0]) { const e = i[0]; e.preserveDrawingBuffer || (e.preserveDrawingBuffer = !0); } else i.splice(0, 1, { preserveDrawingBuffer: !0 }); } return e.apply(this, [o, ...i]); }; })); o.push(i); } catch (e) { console.error("failed to patch HTMLCanvasElement.prototype.getContext"); } return () => { o.forEach((e => e())); }; } function Ke(e, t, r, n, o, i, s) { const a = [], c = Object.getOwnPropertyNames(e); for (const i of c) if (!["isContextLost", "canvas", "drawingBufferWidth", "drawingBufferHeight"].includes(i)) try { if ("function" != typeof e[i]) continue; const c = j(e, i, (function (e) { return function (...a) { const c = e.apply(this, a); if (Ve(c, s, this), "tagName" in this.canvas && !H(this.canvas, n, o, !0)) { const e = Ge(a, s, this), n = { type: t, property: i, args: e }; r(this.canvas, n); } return c; }; })); a.push(c); } catch (n) { const o = U(e, i, { set(e) { r(this.canvas, { type: t, property: i, args: [e], setter: !0 }); } }); a.push(o); } return a; } var Xe, Ye, Ze, et, tt, rt, nt = (Xe = function () { !function () { function e(e, t, r, n) { return new (r || (r = Promise))((function (o, i) { function s(e) { try { c(n.next(e)); } catch (e) { i(e); } } function a(e) { try { c(n.throw(e)); } catch (e) { i(e); } } function c(e) { var t; e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r((function (e) { e(t); }))).then(s, a); } c((n = n.apply(e, t || [])).next()); })); } for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256), n = 0; n < 64; n++)r[t.charCodeAt(n)] = n; var o = function (e) { var r, n = new Uint8Array(e), o = n.length, i = ""; for (r = 0; r < o; r += 3)i += t[n[r] >> 2], i += t[(3 & n[r]) << 4 | n[r + 1] >> 4], i += t[(15 & n[r + 1]) << 2 | n[r + 2] >> 6], i += t[63 & n[r + 2]]; return o % 3 == 2 ? i = i.substring(0, i.length - 1) + "=" : o % 3 == 1 && (i = i.substring(0, i.length - 2) + "=="), i; }; const i = new Map, s = new Map, a = self; a.onmessage = function (t) { return e(this, void 0, void 0, (function* () { if (!("OffscreenCanvas" in globalThis)) return a.postMessage({ id: t.data.id }); { const { id: r, bitmap: n, width: c, height: u, dataURLOptions: l } = t.data, p = function (t, r, n) { return e(this, void 0, void 0, (function* () { const e = `${t}-${r}`; if ("OffscreenCanvas" in globalThis) { if (s.has(e)) return s.get(e); const i = new OffscreenCanvas(t, r); i.getContext("2d"); const a = yield i.convertToBlob(n), c = yield a.arrayBuffer(), u = o(c); return s.set(e, u), u; } return ""; })); }(c, u, l), d = new OffscreenCanvas(c, u); d.getContext("2d").drawImage(n, 0, 0), n.close(); const h = yield d.convertToBlob(l), f = h.type, m = yield h.arrayBuffer(), _ = o(m); if (!i.has(r) && (yield p) === _) return i.set(r, _), a.postMessage({ id: r }); if (i.get(r) === _) return a.postMessage({ id: r }); a.postMessage({ id: r, type: f, base64: _, width: c, height: u }), i.set(r, _); } })); }; }(); }, Ye = null, function (e) { return Ze = Ze || function (e, t) { var r = function (e, t) { var r = void 0 === t ? null : t, n = e.toString().split("\n"); n.pop(), n.shift(); for (var o = n[0].search(/\S/), i = /(['"])__worker_loader_strict__(['"])/g, s = 0, a = n.length; s < a; ++s)n[s] = n[s].substring(o).replace(i, "$1use strict$2") + "\n"; return r && n.push("//# sourceMappingURL=" + r + "\n"), n; }(e, t), n = new Blob(r, { type: "application/javascript" }); return URL.createObjectURL(n); }(Xe, Ye), new Worker(Ze, e); }), ot = class { reset() { this.pendingCanvasMutations.clear(), this.resetObservers && this.resetObservers(); } freeze() { this.frozen = !0; } unfreeze() { this.frozen = !1; } lock() { this.locked = !0; } unlock() { this.locked = !1; } constructor(e) { this.pendingCanvasMutations = new Map, this.rafStamps = { latestId: 0, invokeId: null }, this.frozen = !1, this.locked = !1, this.processMutation = (e, t) => { !(this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId) && this.rafStamps.invokeId || (this.rafStamps.invokeId = this.rafStamps.latestId), this.pendingCanvasMutations.has(e) || this.pendingCanvasMutations.set(e, []), this.pendingCanvasMutations.get(e).push(t); }; const { sampling: t = "all", win: r, blockClass: n, blockSelector: o, recordCanvas: i, dataURLOptions: s } = e; this.mutationCb = e.mutationCb, this.mirror = e.mirror, i && "all" === t && this.initCanvasMutationObserver(r, n, o), i && "number" == typeof t && this.initCanvasFPSObserver(t, r, n, o, { dataURLOptions: s }); } initCanvasFPSObserver(e, t, r, n, o) { const i = Qe(t, r, n, !0), s = new Map, a = new nt; a.onmessage = e => { const { id: t } = e.data; if (s.set(t, !1), !("base64" in e.data)) return; const { base64: r, type: n, width: o, height: i } = e.data; this.mutationCb({ id: t, type: de["2D"], commands: [{ property: "clearRect", args: [0, 0, o, i] }, { property: "drawImage", args: [{ rr_type: "ImageBitmap", args: [{ rr_type: "Blob", data: [{ rr_type: "ArrayBuffer", base64: r }], type: n }] }, 0, 0] }] }); }; const c = 1e3 / e; let u, l = 0; const p = e => { l && e - l < c || (l = e, (() => { const e = []; return t.document.querySelectorAll("canvas").forEach((t => { H(t, r, n, !0) || e.push(t); })), e; })().forEach((e => je(this, void 0, void 0, (function* () { var t; const r = this.mirror.getId(e); if (s.get(r)) return; if (0 === e.width || 0 === e.height) return; if (s.set(r, !0), ["webgl", "webgl2"].includes(e.__context)) { const r = e.getContext(e.__context); !1 === (null === (t = null == r ? void 0 : r.getContextAttributes()) || void 0 === t ? void 0 : t.preserveDrawingBuffer) && r.clear(r.COLOR_BUFFER_BIT); } const n = yield createImageBitmap(e); a.postMessage({ id: r, bitmap: n, width: e.width, height: e.height, dataURLOptions: o.dataURLOptions }, [n]); }))))), u = requestAnimationFrame(p); }; u = requestAnimationFrame(p), this.resetObservers = () => { i(), cancelAnimationFrame(u); }; } initCanvasMutationObserver(e, t, r) { this.startRAFTimestamping(), this.startPendingCanvasMutationFlusher(); const n = Qe(e, t, r, !1), o = function (e, t, r, n) { const o = [], i = Object.getOwnPropertyNames(t.CanvasRenderingContext2D.prototype); for (const s of i) try { if ("function" != typeof t.CanvasRenderingContext2D.prototype[s]) continue; const i = j(t.CanvasRenderingContext2D.prototype, s, (function (o) { return function (...i) { return H(this.canvas, r, n, !0) || setTimeout((() => { const r = Ge(i, t, this); e(this.canvas, { type: de["2D"], property: s, args: r }); }), 0), o.apply(this, i); }; })); o.push(i); } catch (r) { const n = U(t.CanvasRenderingContext2D.prototype, s, { set(t) { e(this.canvas, { type: de["2D"], property: s, args: [t], setter: !0 }); } }); o.push(n); } return () => { o.forEach((e => e())); }; }(this.processMutation.bind(this), e, t, r), i = function (e, t, r, n, o) { const i = []; return i.push(...Ke(t.WebGLRenderingContext.prototype, de.WebGL, e, r, n, 0, t)), void 0 !== t.WebGL2RenderingContext && i.push(...Ke(t.WebGL2RenderingContext.prototype, de.WebGL2, e, r, n, 0, t)), () => { i.forEach((e => e())); }; }(this.processMutation.bind(this), e, t, r, this.mirror); this.resetObservers = () => { n(), o(), i(); }; } startPendingCanvasMutationFlusher() { requestAnimationFrame((() => this.flushPendingCanvasMutations())); } startRAFTimestamping() { const e = t => { this.rafStamps.latestId = t, requestAnimationFrame(e); }; requestAnimationFrame(e); } flushPendingCanvasMutations() { this.pendingCanvasMutations.forEach(((e, t) => { const r = this.mirror.getId(t); this.flushPendingCanvasMutationFor(t, r); })), requestAnimationFrame((() => this.flushPendingCanvasMutations())); } flushPendingCanvasMutationFor(e, t) { if (this.frozen || this.locked) return; const r = this.pendingCanvasMutations.get(e); if (!r || -1 === t) return; const n = r.map((e => { const t = function (e, t) { var r = {}; for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]); if (null != e && "function" == typeof Object.getOwnPropertySymbols) { var o = 0; for (n = Object.getOwnPropertySymbols(e); o < n.length; o++)t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (r[n[o]] = e[n[o]]); } return r; }(e, ["type"]); return t; })), { type: o } = r[0]; this.mutationCb({ id: t, type: o, commands: n }), this.pendingCanvasMutations.delete(e); } }, it = class { constructor(e) { this.trackedLinkElements = new WeakSet, this.styleMirror = new Z, this.mutationCb = e.mutationCb, this.adoptedStyleSheetCb = e.adoptedStyleSheetCb; } attachLinkElement(e, t) { "_cssText" in t.attributes && this.mutationCb({ adds: [], removes: [], texts: [], attributes: [{ id: t.id, attributes: t.attributes }] }), this.trackLinkElement(e); } trackLinkElement(e) { this.trackedLinkElements.has(e) || (this.trackedLinkElements.add(e), this.trackStylesheetInLinkElement(e)); } adoptStyleSheets(e, t) { if (0 === e.length) return; const r = { id: t, styleIds: [] }, n = []; for (const t of e) { let e; this.styleMirror.has(t) ? e = this.styleMirror.getId(t) : (e = this.styleMirror.add(t), n.push({ styleId: e, rules: Array.from(t.rules || CSSRule, ((e, t) => ({ rule: i(e), index: t }))) })), r.styleIds.push(e); } n.length > 0 && (r.styles = n), this.adoptedStyleSheetCb(r); } reset() { this.styleMirror.reset(), this.trackedLinkElements = new WeakSet; } trackStylesheetInLinkElement(e) { } }, st = class { constructor() { this.nodeMap = new WeakMap, this.loop = !0, this.periodicallyClear(); } periodicallyClear() { requestAnimationFrame((() => { this.clear(), this.loop && this.periodicallyClear(); })); } inOtherBuffer(e, t) { const r = this.nodeMap.get(e); return r && Array.from(r).some((e => e !== t)); } add(e, t) { this.nodeMap.set(e, (this.nodeMap.get(e) || new Set).add(t)); } clear() { this.nodeMap = new WeakMap; } destroy() { this.loop = !1; } }; function at(e) { return Object.assign(Object.assign({}, e), { timestamp: B() }); } var ct = !1, ut = new s; function lt(e = {}) { const { emit: t, checkoutEveryNms: r, checkoutEveryNth: n, blockClass: o = "rr-block", blockSelector: i = null, ignoreClass: a = "rr-ignore", ignoreSelector: c = null, maskTextClass: u = "rr-mask", maskTextSelector: l = null, inlineStylesheet: p = !0, maskAllInputs: d, maskInputOptions: h, slimDOMOptions: f, maskInputFn: m, maskTextFn: _, hooks: g, packFn: y, sampling: v = {}, dataURLOptions: b = {}, mousemoveWait: S, recordDOM: k = !0, recordCanvas: w = !1, recordCrossOriginIframes: I = !1, recordAfter: M = ("DOMContentLoaded" === e.recordAfter ? e.recordAfter : "load"), userTriggeredOnInput: C = !1, collectFonts: x = !1, inlineImages: E = !1, plugins: O, keepIframeSrcFn: T = (() => !1), ignoreCSSAttributes: R = new Set([]), errorHandler: D } = e; fe = D; const N = !I || window.parent === window; let q = !1; if (!N) try { window.parent.document && (q = !1); } catch (e) { q = !0; } if (N && !t) throw new Error("emit function is required"); void 0 !== S && void 0 === v.mousemove && (v.mousemove = S), ut.reset(); const F = !0 === d ? { color: !0, date: !0, "datetime-local": !0, email: !0, month: !0, number: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0, textarea: !0, select: !0, password: !0 } : void 0 !== h ? h : { password: !0 }, P = !0 === f || "all" === f ? { script: !0, comment: !0, headFavicon: !0, headWhitespace: !0, headMetaSocial: !0, headMetaRobots: !0, headMetaHttpEquiv: !0, headMetaVerification: !0, headMetaAuthorship: "all" === f, headMetaDescKeywords: "all" === f } : f || {}; let U; !function (e = window) { "NodeList" in e && !e.NodeList.prototype.forEach && (e.NodeList.prototype.forEach = Array.prototype.forEach), "DOMTokenList" in e && !e.DOMTokenList.prototype.forEach && (e.DOMTokenList.prototype.forEach = Array.prototype.forEach), Node.prototype.contains || (Node.prototype.contains = (...e) => { let t = e[0]; if (!(0 in e)) throw new TypeError("1 argument is required"); do { if (this === t) return !0; } while (t = t && t.parentNode); return !1; }); }(); let j = 0; const B = e => { for (const t of O || []) t.eventProcessor && (e = t.eventProcessor(e)); return y && !q && (e = y(e)), e; }; et = (e, o) => { var i; if (!(null === (i = Ie[0]) || void 0 === i ? void 0 : i.isFrozen()) || e.type === ce.FullSnapshot || e.type === ce.IncrementalSnapshot && e.data.source === ue.Mutation || Ie.forEach((e => e.unfreeze())), N) null == t || t(B(e), o); else if (q) { const t = { type: "rrweb", event: B(e), origin: window.location.origin, isCheckout: o }; window.parent.postMessage(t, "*"); } if (e.type === ce.FullSnapshot) U = e, j = 0; else if (e.type === ce.IncrementalSnapshot) { if (e.data.source === ue.Mutation && e.data.isAttachIframe) return; j++; const t = n && j >= n, o = r && e.timestamp - U.timestamp > r; (t || o) && tt(!0); } }; const V = e => { et(at({ type: ce.IncrementalSnapshot, data: Object.assign({ source: ue.Mutation }, e) })); }, H = e => et(at({ type: ce.IncrementalSnapshot, data: Object.assign({ source: ue.Scroll }, e) })), G = e => et(at({ type: ce.IncrementalSnapshot, data: Object.assign({ source: ue.CanvasMutation }, e) })), J = new it({ mutationCb: V, adoptedStyleSheetCb: e => et(at({ type: ce.IncrementalSnapshot, data: Object.assign({ source: ue.AdoptedStyleSheet }, e) })) }), Q = new Pe({ mirror: ut, mutationCb: V, stylesheetManager: J, recordCrossOriginIframes: I, wrappedEmit: et }); for (const e of O || []) e.getMirror && e.getMirror({ nodeMirror: ut, crossOriginIframeMirror: Q.crossOriginIframeMirror, crossOriginIframeStyleMirror: Q.crossOriginIframeStyleMirror }); const Z = new st; rt = new ot({ recordCanvas: w, mutationCb: G, win: window, blockClass: o, blockSelector: i, mirror: ut, sampling: v.canvas, dataURLOptions: b }); const ee = new Ue({ mutationCb: V, scrollCb: H, bypassOptions: { blockClass: o, blockSelector: i, maskTextClass: u, maskTextSelector: l, inlineStylesheet: p, maskInputOptions: F, dataURLOptions: b, maskTextFn: _, maskInputFn: m, recordCanvas: w, inlineImages: E, sampling: v, slimDOMOptions: P, iframeManager: Q, stylesheetManager: J, canvasManager: rt, keepIframeSrcFn: T, processedNodeManager: Z }, mirror: ut }); tt = (e = !1) => { if (!k) return; et(at({ type: ce.Meta, data: { href: window.location.href, width: W(), height: z() } }), e), J.reset(), ee.init(), Ie.forEach((e => e.lock())); const t = function (e, t) { const { mirror: r = new s, blockClass: n = "rr-block", blockSelector: o = null, maskTextClass: i = "rr-mask", maskTextSelector: a = null, inlineStylesheet: c = !0, inlineImages: u = !1, recordCanvas: l = !1, maskAllInputs: p = !1, maskTextFn: d, maskInputFn: h, slimDOM: f = !1, dataURLOptions: m, preserveWhiteSpace: _, onSerialize: g, onIframeLoad: y, iframeLoadTimeout: v, onStylesheetLoad: b, stylesheetLoadTimeout: S, keepIframeSrcFn: k = (() => !1) } = t || {}; return A(e, { doc: e, mirror: r, blockClass: n, blockSelector: o, maskTextClass: i, maskTextSelector: a, skipChild: !1, inlineStylesheet: c, maskInputOptions: !0 === p ? { color: !0, date: !0, "datetime-local": !0, email: !0, month: !0, number: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0, textarea: !0, select: !0, password: !0 } : !1 === p ? { password: !0 } : p, maskTextFn: d, maskInputFn: h, slimDOMOptions: !0 === f || "all" === f ? { script: !0, comment: !0, headFavicon: !0, headWhitespace: !0, headMetaDescKeywords: "all" === f, headMetaSocial: !0, headMetaRobots: !0, headMetaHttpEquiv: !0, headMetaAuthorship: !0, headMetaVerification: !0 } : !1 === f ? {} : f, dataURLOptions: m, inlineImages: u, recordCanvas: l, preserveWhiteSpace: _, onSerialize: g, onIframeLoad: y, iframeLoadTimeout: v, onStylesheetLoad: b, stylesheetLoadTimeout: S, keepIframeSrcFn: k, newlyAddedElement: !1 }); }(document, { mirror: ut, blockClass: o, blockSelector: i, maskTextClass: u, maskTextSelector: l, inlineStylesheet: p, maskAllInputs: F, maskTextFn: _, slimDOM: P, dataURLOptions: b, recordCanvas: w, inlineImages: E, onSerialize: e => { K(e, ut) && Q.addIframe(e), X(e, ut) && J.trackLinkElement(e), Y(e) && ee.addShadowRoot(e.shadowRoot, document); }, onIframeLoad: (e, t) => { Q.attachIframe(e, t), ee.observeAttachShadow(e); }, onStylesheetLoad: (e, t) => { J.attachLinkElement(e, t); }, keepIframeSrcFn: T }); if (!t) return console.warn("Failed to snapshot the document"); et(at({ type: ce.FullSnapshot, data: { node: t, initialOffset: $(window) } }), e), Ie.forEach((e => e.unlock())), document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0 && J.adoptStyleSheets(document.adoptedStyleSheets, ut.getId(document)); }; try { const e = [], t = e => { var t; return we(Ae)({ mutationCb: V, mousemoveCb: (e, t) => et(at({ type: ce.IncrementalSnapshot, data: { source: t, positions: e } })), mouseInteractionCb: e => et(at({ type: ce.IncrementalSnapshot, data: Object.assign({ source: ue.MouseInteraction }, e) })), scrollCb: H, viewportResizeCb: e => et(at({ type: ce.IncrementalSnapshot, data: Object.assign({ source: ue.ViewportResize }, e) })), inputCb: e => et(at({ type: ce.IncrementalSnapshot, data: Object.assign({ source: ue.Input }, e) })), mediaInteractionCb: e => et(at({ type: ce.IncrementalSnapshot, data: Object.assign({ source: ue.MediaInteraction }, e) })), styleSheetRuleCb: e => et(at({ type: ce.IncrementalSnapshot, data: Object.assign({ source: ue.StyleSheetRule }, e) })), styleDeclarationCb: e => et(at({ type: ce.IncrementalSnapshot, data: Object.assign({ source: ue.StyleDeclaration }, e) })), canvasMutationCb: G, fontCb: e => et(at({ type: ce.IncrementalSnapshot, data: Object.assign({ source: ue.Font }, e) })), selectionCb: e => { et(at({ type: ce.IncrementalSnapshot, data: Object.assign({ source: ue.Selection }, e) })); }, customElementCb: e => { et(at({ type: ce.IncrementalSnapshot, data: Object.assign({ source: ue.CustomElement }, e) })); }, blockClass: o, ignoreClass: a, ignoreSelector: c, maskTextClass: u, maskTextSelector: l, maskInputOptions: F, inlineStylesheet: p, sampling: v, recordDOM: k, recordCanvas: w, inlineImages: E, userTriggeredOnInput: C, collectFonts: x, doc: e, maskInputFn: m, maskTextFn: _, keepIframeSrcFn: T, blockSelector: i, slimDOMOptions: P, dataURLOptions: b, mirror: ut, iframeManager: Q, stylesheetManager: J, shadowDomManager: ee, processedNodeManager: Z, canvasManager: rt, ignoreCSSAttributes: R, plugins: (null === (t = null == O ? void 0 : O.filter((e => e.observer))) || void 0 === t ? void 0 : t.map((e => ({ observer: e.observer, options: e.options, callback: t => et(at({ type: ce.Plugin, data: { plugin: e.name, payload: t } })) })))) || [] }, g); }; Q.addLoadListener((r => { try { e.push(t(r.contentDocument)); } catch (e) { console.warn(e); } })); const r = () => { tt(), e.push(t(document)), ct = !0; }; return "interactive" === document.readyState || "complete" === document.readyState ? r() : (e.push(L("DOMContentLoaded", (() => { et(at({ type: ce.DomContentLoaded, data: {} })), "DOMContentLoaded" === M && r(); }))), e.push(L("load", (() => { et(at({ type: ce.Load, data: {} })), "load" === M && r(); }), window))), () => { e.forEach((e => e())), Z.destroy(), ct = !1, fe = void 0; }; } catch (e) { console.warn(e); } } lt.addCustomEvent = (e, t) => { if (!ct) throw new Error("please add custom event after start recording"); et(at({ type: ce.Custom, data: { tag: e, payload: t } })); }, lt.freezePage = () => { Ie.forEach((e => e.freeze())); }, lt.takeFullSnapshot = e => { if (!ct) throw new Error("please take full snapshot after start recording"); tt(e); }, lt.mirror = ut; var pt, dt, ht = (e => (e[e.DomContentLoaded = 0] = "DomContentLoaded", e[e.Load = 1] = "Load", e[e.FullSnapshot = 2] = "FullSnapshot", e[e.IncrementalSnapshot = 3] = "IncrementalSnapshot", e[e.Meta = 4] = "Meta", e[e.Custom = 5] = "Custom", e[e.Plugin = 6] = "Plugin", e))(ht || {}), ft = (e => (e[e.Mutation = 0] = "Mutation", e[e.MouseMove = 1] = "MouseMove", e[e.MouseInteraction = 2] = "MouseInteraction", e[e.Scroll = 3] = "Scroll", e[e.ViewportResize = 4] = "ViewportResize", e[e.Input = 5] = "Input", e[e.TouchMove = 6] = "TouchMove", e[e.MediaInteraction = 7] = "MediaInteraction", e[e.StyleSheetRule = 8] = "StyleSheetRule", e[e.CanvasMutation = 9] = "CanvasMutation", e[e.Font = 10] = "Font", e[e.Log = 11] = "Log", e[e.Drag = 12] = "Drag", e[e.StyleDeclaration = 13] = "StyleDeclaration", e[e.Selection = 14] = "Selection", e[e.AdoptedStyleSheet = 15] = "AdoptedStyleSheet", e[e.CustomElement = 16] = "CustomElement", e))(ft || {}), mt = { DEBUG: !1, LIB_VERSION: "2.55.0" }; pt = "undefined" == typeof window ? { navigator: { userAgent: "" }, document: { location: dt = { hostname: "" }, referrer: "" }, screen: { width: 0, height: 0 }, location: dt } : window; var _t, gt, yt, vt, bt, St, kt, wt, It, Mt, Ct, xt = 864e5, Et = Array.prototype, Ot = Function.prototype, Tt = Object.prototype, Rt = Et.slice, Dt = Tt.toString, Nt = Tt.hasOwnProperty, At = pt.console, Lt = pt.navigator, qt = pt.document, Ft = pt.opera, Pt = pt.screen, Ut = Lt.userAgent, jt = Ot.bind, Bt = Et.forEach, $t = Et.indexOf, zt = Et.map, Wt = Array.isArray, Vt = {}, Ht = { trim: function (e) { return e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""); } }, Gt = { log: function () { if (mt.DEBUG && !Ht.isUndefined(At) && At) try { At.log.apply(At, arguments); } catch (e) { Ht.each(arguments, (function (e) { At.log(e); })); } }, warn: function () { if (mt.DEBUG && !Ht.isUndefined(At) && At) { var e = ["Mixpanel warning:"].concat(Ht.toArray(arguments)); try { At.warn.apply(At, e); } catch (t) { Ht.each(e, (function (e) { At.warn(e); })); } } }, error: function () { if (mt.DEBUG && !Ht.isUndefined(At) && At) { var e = ["Mixpanel error:"].concat(Ht.toArray(arguments)); try { At.error.apply(At, e); } catch (t) { Ht.each(e, (function (e) { At.error(e); })); } } }, critical: function () { if (!Ht.isUndefined(At) && At) { var e = ["Mixpanel error:"].concat(Ht.toArray(arguments)); try { At.error.apply(At, e); } catch (t) { Ht.each(e, (function (e) { At.error(e); })); } } } }, Jt = function (e, t) { return function () { return arguments[0] = "[" + t + "] " + arguments[0], e.apply(Gt, arguments); }; }, Qt = function (e) { return { log: Jt(Gt.log, e), error: Jt(Gt.error, e), critical: Jt(Gt.critical, e) }; }; Ht.bind = function (e, t) { var r, n; if (jt && e.bind === jt) return jt.apply(e, Rt.call(arguments, 1)); if (!Ht.isFunction(e)) throw new TypeError; return r = Rt.call(arguments, 2), n = function () { if (!(this instanceof n)) return e.apply(t, r.concat(Rt.call(arguments))); var o = {}; o.prototype = e.prototype; var i = new o; o.prototype = null; var s = e.apply(i, r.concat(Rt.call(arguments))); return Object(s) === s ? s : i; }, n; }, Ht.each = function (e, t, r) { if (null != e) if (Bt && e.forEach === Bt) e.forEach(t, r); else if (e.length === +e.length) { for (var n = 0, o = e.length; n < o; n++)if (n in e && t.call(r, e[n], n, e) === Vt) return; } else for (var i in e) if (Nt.call(e, i) && t.call(r, e[i], i, e) === Vt) return; }, Ht.extend = function (e) { return Ht.each(Rt.call(arguments, 1), (function (t) { for (var r in t) void 0 !== t[r] && (e[r] = t[r]); })), e; }, Ht.isArray = Wt || function (e) { return "[object Array]" === Dt.call(e); }, Ht.isFunction = function (e) { try { return /^\s*\bfunction\b/.test(e); } catch (e) { return !1; } }, Ht.isArguments = function (e) { return !(!e || !Nt.call(e, "callee")); }, Ht.toArray = function (e) { return e ? e.toArray ? e.toArray() : Ht.isArray(e) || Ht.isArguments(e) ? Rt.call(e) : Ht.values(e) : []; }, Ht.map = function (e, t, r) { if (zt && e.map === zt) return e.map(t, r); var n = []; return Ht.each(e, (function (e) { n.push(t.call(r, e)); })), n; }, Ht.keys = function (e) { var t = []; return null === e || Ht.each(e, (function (e, r) { t[t.length] = r; })), t; }, Ht.values = function (e) { var t = []; return null === e || Ht.each(e, (function (e) { t[t.length] = e; })), t; }, Ht.include = function (e, t) { var r = !1; return null === e ? r : $t && e.indexOf === $t ? -1 != e.indexOf(t) : (Ht.each(e, (function (e) { if (r || (r = e === t)) return Vt; })), r); }, Ht.includes = function (e, t) { return -1 !== e.indexOf(t); }, Ht.inherit = function (e, t) { return e.prototype = new t, e.prototype.constructor = e, e.superclass = t.prototype, e; }, Ht.isObject = function (e) { return e === Object(e) && !Ht.isArray(e); }, Ht.isEmptyObject = function (e) { if (Ht.isObject(e)) { for (var t in e) if (Nt.call(e, t)) return !1; return !0; } return !1; }, Ht.isUndefined = function (e) { return void 0 === e; }, Ht.isString = function (e) { return "[object String]" == Dt.call(e); }, Ht.isDate = function (e) { return "[object Date]" == Dt.call(e); }, Ht.isNumber = function (e) { return "[object Number]" == Dt.call(e); }, Ht.isElement = function (e) { return !(!e || 1 !== e.nodeType); }, Ht.encodeDates = function (e) { return Ht.each(e, (function (t, r) { Ht.isDate(t) ? e[r] = Ht.formatDate(t) : Ht.isObject(t) && (e[r] = Ht.encodeDates(t)); })), e; }, Ht.timestamp = function () { return Date.now = Date.now || function () { return +new Date; }, Date.now(); }, Ht.formatDate = function (e) { function t(e) { return e < 10 ? "0" + e : e; } return e.getUTCFullYear() + "-" + t(e.getUTCMonth() + 1) + "-" + t(e.getUTCDate()) + "T" + t(e.getUTCHours()) + ":" + t(e.getUTCMinutes()) + ":" + t(e.getUTCSeconds()); }, Ht.strip_empty_properties = function (e) { var t = {}; return Ht.each(e, (function (e, r) { Ht.isString(e) && e.length > 0 && (t[r] = e); })), t; }, Ht.truncate = function (e, t) { var r; return "string" == typeof e ? r = e.slice(0, t) : Ht.isArray(e) ? (r = [], Ht.each(e, (function (e) { r.push(Ht.truncate(e, t)); }))) : Ht.isObject(e) ? (r = {}, Ht.each(e, (function (e, n) { r[n] = Ht.truncate(e, t); }))) : r = e, r; }, Ht.JSONEncode = function (e) { var t = function (e) { var t = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, r = { "\b": "\\b", "\t": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\" }; return t.lastIndex = 0, t.test(e) ? '"' + e.replace(t, (function (e) { var t = r[e]; return "string" == typeof t ? t : "\\u" + ("0000" + e.charCodeAt(0).toString(16)).slice(-4); })) + '"' : '"' + e + '"'; }, r = function (e, n) { var o = "", i = 0, s = "", a = "", c = 0, u = o, l = [], p = n[e]; switch (p && "object" == typeof p && "function" == typeof p.toJSON && (p = p.toJSON(e)), typeof p) { case "string": return t(p); case "number": return isFinite(p) ? String(p) : "null"; case "boolean": case "null": return String(p); case "object": if (!p) return "null"; if (o += "    ", l = [], "[object Array]" === Dt.apply(p)) { for (c = p.length, i = 0; i < c; i += 1)l[i] = r(i, p) || "null"; return a = 0 === l.length ? "[]" : o ? "[\n" + o + l.join(",\n" + o) + "\n" + u + "]" : "[" + l.join(",") + "]", o = u, a; } for (s in p) Nt.call(p, s) && (a = r(s, p)) && l.push(t(s) + (o ? ": " : ":") + a); return a = 0 === l.length ? "{}" : o ? "{" + l.join(",") + u + "}" : "{" + l.join(",") + "}", o = u, a; } }; return r("", { "": e }); }, Ht.JSONDecode = (bt = { '"': '"', "\\": "\\", "/": "/", b: "\b", f: "\f", n: "\n", r: "\r", t: "\t" }, St = function (e) { var t = new SyntaxError(e); throw t.at = _t, t.text = yt, t; }, kt = function (e) { return e && e !== gt && St("Expected '" + e + "' instead of '" + gt + "'"), gt = yt.charAt(_t), _t += 1, gt; }, wt = function () { var e, t = ""; for ("-" === gt && (t = "-", kt("-")); gt >= "0" && gt <= "9";)t += gt, kt(); if ("." === gt) for (t += "."; kt() && gt >= "0" && gt <= "9";)t += gt; if ("e" === gt || "E" === gt) for (t += gt, kt(), "-" !== gt && "+" !== gt || (t += gt, kt()); gt >= "0" && gt <= "9";)t += gt, kt(); if (e = +t, isFinite(e)) return e; St("Bad number"); }, It = function () { var e, t, r, n = ""; if ('"' === gt) for (; kt();) { if ('"' === gt) return kt(), n; if ("\\" === gt) if (kt(), "u" === gt) { for (r = 0, t = 0; t < 4 && (e = parseInt(kt(), 16), isFinite(e)); t += 1)r = 16 * r + e; n += String.fromCharCode(r); } else { if ("string" != typeof bt[gt]) break; n += bt[gt]; } else n += gt; } St("Bad string"); }, Mt = function () { for (; gt && gt <= " ";)kt(); }, vt = function () { switch (Mt(), gt) { case "{": return function () { var e, t = {}; if ("{" === gt) { if (kt("{"), Mt(), "}" === gt) return kt("}"), t; for (; gt;) { if (e = It(), Mt(), kt(":"), Object.hasOwnProperty.call(t, e) && St('Duplicate key "' + e + '"'), t[e] = vt(), Mt(), "}" === gt) return kt("}"), t; kt(","), Mt(); } } St("Bad object"); }(); case "[": return function () { var e = []; if ("[" === gt) { if (kt("["), Mt(), "]" === gt) return kt("]"), e; for (; gt;) { if (e.push(vt()), Mt(), "]" === gt) return kt("]"), e; kt(","), Mt(); } } St("Bad array"); }(); case '"': return It(); case "-": return wt(); default: return gt >= "0" && gt <= "9" ? wt() : function () { switch (gt) { case "t": return kt("t"), kt("r"), kt("u"), kt("e"), !0; case "f": return kt("f"), kt("a"), kt("l"), kt("s"), kt("e"), !1; case "n": return kt("n"), kt("u"), kt("l"), kt("l"), null; }St('Unexpected "' + gt + '"'); }(); } }, function (e) { var t; return yt = e, _t = 0, gt = " ", t = vt(), Mt(), gt && St("Syntax error"), t; }), Ht.base64Encode = function (e) { var t, r, n, o, i, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", a = 0, c = 0, u = "", l = []; if (!e) return e; e = Ht.utf8Encode(e); do { t = (i = e.charCodeAt(a++) << 16 | e.charCodeAt(a++) << 8 | e.charCodeAt(a++)) >> 18 & 63, r = i >> 12 & 63, n = i >> 6 & 63, o = 63 & i, l[c++] = s.charAt(t) + s.charAt(r) + s.charAt(n) + s.charAt(o); } while (a < e.length); switch (u = l.join(""), e.length % 3) { case 1: u = u.slice(0, -2) + "=="; break; case 2: u = u.slice(0, -1) + "="; }return u; }, Ht.utf8Encode = function (e) { var t, r, n, o, i = ""; for (t = r = 0, n = (e = (e + "").replace(/\r\n/g, "\n").replace(/\r/g, "\n")).length, o = 0; o < n; o++) { var s = e.charCodeAt(o), a = null; s < 128 ? r++ : a = s > 127 && s < 2048 ? String.fromCharCode(s >> 6 | 192, 63 & s | 128) : String.fromCharCode(s >> 12 | 224, s >> 6 & 63 | 128, 63 & s | 128), null !== a && (r > t && (i += e.substring(t, r)), i += a, t = r = o + 1); } return r > t && (i += e.substring(t, e.length)), i; }, Ht.UUID = (Ct = function () { var e, t = 1 * new Date; if (pt.performance && pt.performance.now) e = pt.performance.now(); else for (e = 0; t == 1 * new Date;)e++; return t.toString(16) + Math.floor(e).toString(16); }, function () { var e = (Pt.height * Pt.width).toString(16); return Ct() + "-" + Math.random().toString(16).replace(".", "") + "-" + function () { var e, t, r = Ut, n = [], o = 0; function i(e, t) { var r, o = 0; for (r = 0; r < t.length; r++)o |= n[r] << 8 * r; return e ^ o; } for (e = 0; e < r.length; e++)t = r.charCodeAt(e), n.unshift(255 & t), n.length >= 4 && (o = i(o, n), n = []); return n.length > 0 && (o = i(o, n)), o.toString(16); }() + "-" + e + "-" + Ct(); }); var Kt = ["ahrefsbot", "ahrefssiteaudit", "baiduspider", "bingbot", "bingpreview", "chrome-lighthouse", "facebookexternal", "petalbot", "pinterest", "screaming frog", "yahoo! slurp", "yandexbot", "adsbot-google", "apis-google", "duplexweb-google", "feedfetcher-google", "google favicon", "google web preview", "google-read-aloud", "googlebot", "googleweblight", "mediapartners-google", "storebot-google"]; Ht.isBlockedUA = function (e) { var t; for (e = e.toLowerCase(), t = 0; t < Kt.length; t++)if (-1 !== e.indexOf(Kt[t])) return !0; return !1; }, Ht.HTTPBuildQuery = function (e, t) { var r, n, o = []; return Ht.isUndefined(t) && (t = "&"), Ht.each(e, (function (e, t) { r = encodeURIComponent(e.toString()), n = encodeURIComponent(t), o[o.length] = n + "=" + r; })), o.join(t); }, Ht.getQueryParam = function (e, t) { t = t.replace(/[[]/, "\\[").replace(/[\]]/, "\\]"); var r = new RegExp("[\\?&]" + t + "=([^&#]*)").exec(e); if (null === r || r && "string" != typeof r[1] && r[1].length) return ""; var n = r[1]; try { n = decodeURIComponent(n); } catch (e) { Gt.error("Skipping decoding for malformed query param: " + n); } return n.replace(/\+/g, " "); }, Ht.cookie = { get: function (e) { for (var t = e + "=", r = qt.cookie.split(";"), n = 0; n < r.length; n++) { for (var o = r[n]; " " == o.charAt(0);)o = o.substring(1, o.length); if (0 === o.indexOf(t)) return decodeURIComponent(o.substring(t.length, o.length)); } return null; }, parse: function (e) { var t; try { t = Ht.JSONDecode(Ht.cookie.get(e)) || {}; } catch (e) { } return t; }, set_seconds: function (e, t, r, n, o, i, s) { var a = "", c = "", u = ""; if (s) a = "; domain=" + s; else if (n) { var l = ir(qt.location.hostname); a = l ? "; domain=." + l : ""; } if (r) { var p = new Date; p.setTime(p.getTime() + 1e3 * r), c = "; expires=" + p.toGMTString(); } i && (o = !0, u = "; SameSite=None"), o && (u += "; secure"), qt.cookie = e + "=" + encodeURIComponent(t) + c + "; path=/" + a + u; }, set: function (e, t, r, n, o, i, s) { var a = "", c = "", u = ""; if (s) a = "; domain=" + s; else if (n) { var l = ir(qt.location.hostname); a = l ? "; domain=." + l : ""; } if (r) { var p = new Date; p.setTime(p.getTime() + 24 * r * 60 * 60 * 1e3), c = "; expires=" + p.toGMTString(); } i && (o = !0, u = "; SameSite=None"), o && (u += "; secure"); var d = e + "=" + encodeURIComponent(t) + c + "; path=/" + a + u; return qt.cookie = d, d; }, remove: function (e, t, r) { Ht.cookie.set(e, "", -1, t, !1, !1, r); } }; var Xt = null, Yt = function (e, t) { if (null !== Xt && !t) return Xt; var r = !0; try { e = e || window.localStorage; var n = "__mplss_" + rr(8); e.setItem(n, "xyz"), "xyz" !== e.getItem(n) && (r = !1), e.removeItem(n); } catch (e) { r = !1; } return Xt = r, r; }; Ht.localStorage = { is_supported: function (e) { var t = Yt(null, e); return t || Gt.error("localStorage unsupported; falling back to cookie store"), t; }, error: function (e) { Gt.error("localStorage error: " + e); }, get: function (e) { try { return window.localStorage.getItem(e); } catch (e) { Ht.localStorage.error(e); } return null; }, parse: function (e) { try { return Ht.JSONDecode(Ht.localStorage.get(e)) || {}; } catch (e) { } return null; }, set: function (e, t) { try { window.localStorage.setItem(e, t); } catch (e) { Ht.localStorage.error(e); } }, remove: function (e) { try { window.localStorage.removeItem(e); } catch (e) { Ht.localStorage.error(e); } } }, Ht.register_event = function () { function e(t) { return t && (t.preventDefault = e.preventDefault, t.stopPropagation = e.stopPropagation), t; } return e.preventDefault = function () { this.returnValue = !1; }, e.stopPropagation = function () { this.cancelBubble = !0; }, function (t, r, n, o, i) { if (t) if (t.addEventListener && !o) t.addEventListener(r, n, !!i); else { var s = "on" + r, a = t[s]; t[s] = function (t, r, n) { var o = function (o) { if (o = o || e(window.event)) { var i, s, a = !0; return Ht.isFunction(n) && (i = n(o)), s = r.call(t, o), !1 !== i && !1 !== s || (a = !1), a; } }; return o; }(t, n, a); } else Gt.error("No valid element provided to register_event"); }; }(); var Zt = new RegExp('^(\\w*)\\[(\\w+)([=~\\|\\^\\$\\*]?)=?"?([^\\]"]*)"?\\]$'); Ht.dom_query = function () { function e(e) { return e.all ? e.all : e.getElementsByTagName("*"); } var t = /[\t\r\n]/g; function r(e, r) { var n = " " + r + " "; return (" " + e.className + " ").replace(t, " ").indexOf(n) >= 0; } function n(t) { if (!qt.getElementsByTagName) return []; var n, o, i, s, a, c, u, l, p, d, h = t.split(" "), f = [qt]; for (c = 0; c < h.length; c++)if ((n = h[c].replace(/^\s+/, "").replace(/\s+$/, "")).indexOf("#") > -1) { i = (o = n.split("#"))[0]; var m = o[1], _ = qt.getElementById(m); if (!_ || i && _.nodeName.toLowerCase() != i) return []; f = [_]; } else if (n.indexOf(".") > -1) { i = (o = n.split("."))[0]; var g = o[1]; for (i || (i = "*"), s = [], a = 0, u = 0; u < f.length; u++)for (p = "*" == i ? e(f[u]) : f[u].getElementsByTagName(i), l = 0; l < p.length; l++)s[a++] = p[l]; for (f = [], d = 0, u = 0; u < s.length; u++)s[u].className && Ht.isString(s[u].className) && r(s[u], g) && (f[d++] = s[u]); } else { var y = n.match(Zt); if (y) { i = y[1]; var v, b = y[2], S = y[3], k = y[4]; for (i || (i = "*"), s = [], a = 0, u = 0; u < f.length; u++)for (p = "*" == i ? e(f[u]) : f[u].getElementsByTagName(i), l = 0; l < p.length; l++)s[a++] = p[l]; switch (f = [], d = 0, S) { case "=": v = function (e) { return e.getAttribute(b) == k; }; break; case "~": v = function (e) { return e.getAttribute(b).match(new RegExp("\\b" + k + "\\b")); }; break; case "|": v = function (e) { return e.getAttribute(b).match(new RegExp("^" + k + "-?")); }; break; case "^": v = function (e) { return 0 === e.getAttribute(b).indexOf(k); }; break; case "$": v = function (e) { return e.getAttribute(b).lastIndexOf(k) == e.getAttribute(b).length - k.length; }; break; case "*": v = function (e) { return e.getAttribute(b).indexOf(k) > -1; }; break; default: v = function (e) { return e.getAttribute(b); }; }for (f = [], d = 0, u = 0; u < s.length; u++)v(s[u]) && (f[d++] = s[u]); } else { for (i = n, s = [], a = 0, u = 0; u < f.length; u++)for (p = f[u].getElementsByTagName(i), l = 0; l < p.length; l++)s[a++] = p[l]; f = s; } } return f; } return function (e) { return Ht.isElement(e) ? [e] : Ht.isObject(e) && !Ht.isUndefined(e.length) ? e : n.call(this, e); }; }(); var er = ["utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term"], tr = ["dclid", "fbclid", "gclid", "ko_click_id", "li_fat_id", "msclkid", "ttclid", "twclid", "wbraid"]; Ht.info = { campaignParams: function (e) { var t = "", r = {}; return Ht.each(er, (function (n) { (t = Ht.getQueryParam(qt.URL, n)).length ? r[n] = t : void 0 !== e && (r[n] = e); })), r; }, clickParams: function () { var e = "", t = {}; return Ht.each(tr, (function (r) { (e = Ht.getQueryParam(qt.URL, r)).length && (t[r] = e); })), t; }, marketingParams: function () { return Ht.extend(Ht.info.campaignParams(), Ht.info.clickParams()); }, searchEngine: function (e) { return 0 === e.search("https?://(.*)google.([^/?]*)") ? "google" : 0 === e.search("https?://(.*)bing.com") ? "bing" : 0 === e.search("https?://(.*)yahoo.com") ? "yahoo" : 0 === e.search("https?://(.*)duckduckgo.com") ? "duckduckgo" : null; }, searchInfo: function (e) { var t = Ht.info.searchEngine(e), r = "yahoo" != t ? "q" : "p", n = {}; if (null !== t) { n.$search_engine = t; var o = Ht.getQueryParam(e, r); o.length && (n.mp_keyword = o); } return n; }, browser: function (e, t, r) { return t = t || "", r || Ht.includes(e, " OPR/") ? Ht.includes(e, "Mini") ? "Opera Mini" : "Opera" : /(BlackBerry|PlayBook|BB10)/i.test(e) ? "BlackBerry" : Ht.includes(e, "IEMobile") || Ht.includes(e, "WPDesktop") ? "Internet Explorer Mobile" : Ht.includes(e, "SamsungBrowser/") ? "Samsung Internet" : Ht.includes(e, "Edge") || Ht.includes(e, "Edg/") ? "Microsoft Edge" : Ht.includes(e, "FBIOS") ? "Facebook Mobile" : Ht.includes(e, "Chrome") ? "Chrome" : Ht.includes(e, "CriOS") ? "Chrome iOS" : Ht.includes(e, "UCWEB") || Ht.includes(e, "UCBrowser") ? "UC Browser" : Ht.includes(e, "FxiOS") ? "Firefox iOS" : Ht.includes(t, "Apple") ? Ht.includes(e, "Mobile") ? "Mobile Safari" : "Safari" : Ht.includes(e, "Android") ? "Android Mobile" : Ht.includes(e, "Konqueror") ? "Konqueror" : Ht.includes(e, "Firefox") ? "Firefox" : Ht.includes(e, "MSIE") || Ht.includes(e, "Trident/") ? "Internet Explorer" : Ht.includes(e, "Gecko") ? "Mozilla" : ""; }, browserVersion: function (e, t, r) { var n = { "Internet Explorer Mobile": /rv:(\d+(\.\d+)?)/, "Microsoft Edge": /Edge?\/(\d+(\.\d+)?)/, Chrome: /Chrome\/(\d+(\.\d+)?)/, "Chrome iOS": /CriOS\/(\d+(\.\d+)?)/, "UC Browser": /(UCBrowser|UCWEB)\/(\d+(\.\d+)?)/, Safari: /Version\/(\d+(\.\d+)?)/, "Mobile Safari": /Version\/(\d+(\.\d+)?)/, Opera: /(Opera|OPR)\/(\d+(\.\d+)?)/, Firefox: /Firefox\/(\d+(\.\d+)?)/, "Firefox iOS": /FxiOS\/(\d+(\.\d+)?)/, Konqueror: /Konqueror:(\d+(\.\d+)?)/, BlackBerry: /BlackBerry (\d+(\.\d+)?)/, "Android Mobile": /android\s(\d+(\.\d+)?)/, "Samsung Internet": /SamsungBrowser\/(\d+(\.\d+)?)/, "Internet Explorer": /(rv:|MSIE )(\d+(\.\d+)?)/, Mozilla: /rv:(\d+(\.\d+)?)/ }[Ht.info.browser(e, t, r)]; if (void 0 === n) return null; var o = e.match(n); return o ? parseFloat(o[o.length - 2]) : null; }, os: function () { var e = Ut; return /Windows/i.test(e) ? /Phone/.test(e) || /WPDesktop/.test(e) ? "Windows Phone" : "Windows" : /(iPhone|iPad|iPod)/.test(e) ? "iOS" : /Android/.test(e) ? "Android" : /(BlackBerry|PlayBook|BB10)/i.test(e) ? "BlackBerry" : /Mac/i.test(e) ? "Mac OS X" : /Linux/.test(e) ? "Linux" : /CrOS/.test(e) ? "Chrome OS" : ""; }, device: function (e) { return /Windows Phone/i.test(e) || /WPDesktop/.test(e) ? "Windows Phone" : /iPad/.test(e) ? "iPad" : /iPod/.test(e) ? "iPod Touch" : /iPhone/.test(e) ? "iPhone" : /(BlackBerry|PlayBook|BB10)/i.test(e) ? "BlackBerry" : /Android/.test(e) ? "Android" : ""; }, referringDomain: function (e) { var t = e.split("/"); return t.length >= 3 ? t[2] : ""; }, currentUrl: function () { return pt.location.href; }, properties: function (e) { return "object" != typeof e && (e = {}), Ht.extend(Ht.strip_empty_properties({ $os: Ht.info.os(), $browser: Ht.info.browser(Ut, Lt.vendor, Ft), $referrer: qt.referrer, $referring_domain: Ht.info.referringDomain(qt.referrer), $device: Ht.info.device(Ut) }), { $current_url: Ht.info.currentUrl(), $browser_version: Ht.info.browserVersion(Ut, Lt.vendor, Ft), $screen_height: Pt.height, $screen_width: Pt.width, mp_lib: "web", $lib_version: mt.LIB_VERSION, $insert_id: rr(), time: Ht.timestamp() / 1e3 }, Ht.strip_empty_properties(e)); }, people_properties: function () { return Ht.extend(Ht.strip_empty_properties({ $os: Ht.info.os(), $browser: Ht.info.browser(Ut, Lt.vendor, Ft) }), { $browser_version: Ht.info.browserVersion(Ut, Lt.vendor, Ft) }); }, mpPageViewProperties: function () { return Ht.strip_empty_properties({ current_page_title: qt.title, current_domain: pt.location.hostname, current_url_path: pt.location.pathname, current_url_protocol: pt.location.protocol, current_url_search: pt.location.search }); } }; var rr = function (e) { var t = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10); return e ? t.substring(0, e) : t; }, nr = /[a-z0-9][a-z0-9-]*\.[a-z]+$/i, or = /[a-z0-9][a-z0-9-]+\.[a-z.]{2,6}$/i, ir = function (e) { var t = or, r = e.split("."), n = r[r.length - 1]; (n.length > 4 || "com" === n || "org" === n) && (t = nr); var o = e.match(t); return o ? o[0] : ""; }, sr = null, ar = null; "undefined" != typeof JSON && (sr = JSON.stringify, ar = JSON.parse), sr = sr || Ht.JSONEncode, ar = ar || Ht.JSONDecode, Ht.toArray = Ht.toArray, Ht.isObject = Ht.isObject, Ht.JSONEncode = Ht.JSONEncode, Ht.JSONDecode = Ht.JSONDecode, Ht.isBlockedUA = Ht.isBlockedUA, Ht.isEmptyObject = Ht.isEmptyObject, Ht.info = Ht.info, Ht.info.device = Ht.info.device, Ht.info.browser = Ht.info.browser, Ht.info.browserVersion = Ht.info.browserVersion, Ht.info.properties = Ht.info.properties; var cr = "__mp_opt_in_out_"; function ur(e, t) { br(!0, e, t); } function lr(e, t) { br(!1, e, t); } function pr(e, t) { return "1" === vr(e, t); } function dr(e, t) { if (function (e) { if (e && e.ignoreDnt) return !1; var t = e && e.window || pt, r = t.navigator || {}, n = !1; return Ht.each([r.doNotTrack, r.msDoNotTrack, t.doNotTrack], (function (e) { Ht.includes([!0, 1, "1", "yes"], e) && (n = !0); })), n; }(t)) return Gt.warn('This browser has "Do Not Track" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the "Do Not Track" browser setting, initialize the Mixpanel instance with the config "ignore_dnt: true"'), !0; var r = "0" === vr(e, t); return r && Gt.warn("You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data."), r; } function hr(e) { return Sr(e, (function (e) { return this.get_config(e); })); } function fr(e) { return Sr(e, (function (e) { return this._get_config(e); })); } function mr(e) { return Sr(e, (function (e) { return this._get_config(e); })); } function _r(e, t) { gr(t = t || {}).remove(yr(e, t), !!t.crossSubdomainCookie, t.cookieDomain); } function gr(e) { return "localStorage" === (e = e || {}).persistenceType ? Ht.localStorage : Ht.cookie; } function yr(e, t) { return ((t = t || {}).persistencePrefix || cr) + e; } function vr(e, t) { return gr(t).get(yr(e, t)); } function br(e, t, r) { Ht.isString(t) && t.length ? (gr(r = r || {}).set(yr(t, r), e ? 1 : 0, Ht.isNumber(r.cookieExpiration) ? r.cookieExpiration : null, !!r.crossSubdomainCookie, !!r.secureCookie, !!r.crossSiteCookie, r.cookieDomain), r.track && e && r.track(r.trackEventName || "$opt_in", r.trackProperties, { send_immediately: !0 })) : Gt.error("gdpr." + (e ? "optIn" : "optOut") + " called with an invalid token"); } function Sr(e, t) { return function () { var r = !1; try { var n = t.call(this, "token"), o = t.call(this, "ignore_dnt"), i = t.call(this, "opt_out_tracking_persistence_type"), s = t.call(this, "opt_out_tracking_cookie_prefix"), a = t.call(this, "window"); n && (r = dr(n, { ignoreDnt: o, persistenceType: i, persistencePrefix: s, window: a })); } catch (e) { Gt.error("Unexpected error when checking tracking opt-out status: " + e); } if (!r) return e.apply(this, arguments); var c = arguments[arguments.length - 1]; "function" == typeof c && c(0); }; } var kr = Qt("lock"), wr = function (e, t) { t = t || {}, this.storageKey = e, this.storage = t.storage || window.localStorage, this.pollIntervalMS = t.pollIntervalMS || 100, this.timeoutMS = t.timeoutMS || 2e3; }; wr.prototype.withLock = function (e, t, r) { r || "function" == typeof t || (r = t, t = null); var n = r || (new Date).getTime() + "|" + Math.random(), o = (new Date).getTime(), i = this.storageKey, s = this.pollIntervalMS, a = this.timeoutMS, c = this.storage, u = i + ":X", l = i + ":Y", p = i + ":Z", d = function (e) { t && t(e); }, h = function (e) { if ((new Date).getTime() - o > a) return kr.error("Timeout waiting for mutex on " + i + "; clearing lock. [" + n + "]"), c.removeItem(p), c.removeItem(l), void _(); setTimeout((function () { try { e(); } catch (e) { d(e); } }), s * (Math.random() + .1)); }, f = function (e, t) { e() ? t() : h((function () { f(e, t); })); }, m = function () { var e = c.getItem(l); if (e && e !== n) return !1; if (c.setItem(l, n), c.getItem(l) === n) return !0; if (!Yt(c, !0)) throw new Error("localStorage support dropped while acquiring lock"); return !1; }, _ = function () { c.setItem(u, n), f(m, (function () { c.getItem(u) !== n ? h((function () { c.getItem(l) === n ? f((function () { return !c.getItem(p); }), g) : _(); })) : g(); })); }, g = function () { c.setItem(p, "1"); try { e(); } finally { c.removeItem(p), c.getItem(l) === n && c.removeItem(l), c.getItem(u) === n && c.removeItem(u); } }; try { if (!Yt(c, !0)) throw new Error("localStorage support check failed"); _(); } catch (e) { d(e); } }; var Ir = Qt("batch"), Mr = function (e, t) { t = t || {}, this.storageKey = e, this.storage = t.storage || window.localStorage, this.reportError = t.errorReporter || Ht.bind(Ir.error, Ir), this.lock = new wr(e, { storage: this.storage }), this.usePersistence = t.usePersistence, this.pid = t.pid || null, this.memQueue = []; }; Mr.prototype.enqueue = function (e, t, r) { var n = { id: rr(), flushAfter: (new Date).getTime() + 2 * t, payload: e }; this.usePersistence ? this.lock.withLock(Ht.bind((function () { var t; try { var o = this.readFromStorage(); o.push(n), (t = this.saveToStorage(o)) && this.memQueue.push(n); } catch (r) { this.reportError("Error enqueueing item", e), t = !1; } r && r(t); }), this), Ht.bind((function (e) { this.reportError("Error acquiring storage lock", e), r && r(!1); }), this), this.pid) : (this.memQueue.push(n), r && r(!0)); }, Mr.prototype.fillBatch = function (e) { var t = this.memQueue.slice(0, e); if (this.usePersistence && t.length < e) { var r = this.readFromStorage(); if (r.length) { var n = {}; Ht.each(t, (function (e) { n[e.id] = !0; })); for (var o = 0; o < r.length; o++) { var i = r[o]; if ((new Date).getTime() > i.flushAfter && !n[i.id] && (i.orphaned = !0, t.push(i), t.length >= e)) break; } } } return t; }; var Cr = function (e, t) { var r = []; return Ht.each(e, (function (e) { e.id && !t[e.id] && r.push(e); })), r; }; Mr.prototype.removeItemsByID = function (e, t) { var r = {}; if (Ht.each(e, (function (e) { r[e] = !0; })), this.memQueue = Cr(this.memQueue, r), this.usePersistence) { var n = Ht.bind((function () { var t; try { var n = this.readFromStorage(); if (n = Cr(n, r), t = this.saveToStorage(n)) { n = this.readFromStorage(); for (var o = 0; o < n.length; o++) { var i = n[o]; if (i.id && r[i.id]) return this.reportError("Item not removed from storage"), !1; } } } catch (r) { this.reportError("Error removing items", e), t = !1; } return t; }), this); this.lock.withLock((function () { var e = n(); t && t(e); }), Ht.bind((function (e) { var r = !1; if (this.reportError("Error acquiring storage lock", e), !Yt(this.storage, !0) && !(r = n())) try { this.storage.removeItem(this.storageKey); } catch (e) { this.reportError("Error clearing queue", e); } t && t(r); }), this), this.pid); } else t && t(!0); }; var xr = function (e, t) { var r = []; return Ht.each(e, (function (e) { var n = e.id; if (n in t) { var o = t[n]; null !== o && (e.payload = o, r.push(e)); } else r.push(e); })), r; }; Mr.prototype.updatePayloads = function (e, t) { this.memQueue = xr(this.memQueue, e), this.usePersistence ? this.lock.withLock(Ht.bind((function () { var r; try { var n = this.readFromStorage(); n = xr(n, e), r = this.saveToStorage(n); } catch (t) { this.reportError("Error updating items", e), r = !1; } t && t(r); }), this), Ht.bind((function (e) { this.reportError("Error acquiring storage lock", e), t && t(!1); }), this), this.pid) : t && t(!0); }, Mr.prototype.readFromStorage = function () { var e; try { (e = this.storage.getItem(this.storageKey)) && (e = ar(e), Ht.isArray(e) || (this.reportError("Invalid storage entry:", e), e = null)); } catch (t) { this.reportError("Error retrieving queue", t), e = null; } return e || []; }, Mr.prototype.saveToStorage = function (e) { try { return this.storage.setItem(this.storageKey, sr(e)), !0; } catch (e) { return this.reportError("Error saving queue", e), !1; } }, Mr.prototype.clear = function () { this.memQueue = [], this.usePersistence && this.storage.removeItem(this.storageKey); }; var Er = Qt("batch"), Or = function (e, t) { this.errorReporter = t.errorReporter, this.queue = new Mr(e, { errorReporter: Ht.bind(this.reportError, this), storage: t.storage, usePersistence: t.usePersistence }), this.libConfig = t.libConfig, this.sendRequest = t.sendRequestFunc, this.beforeSendHook = t.beforeSendHook, this.stopAllBatching = t.stopAllBatchingFunc, this.batchSize = this.libConfig.batch_size, this.flushInterval = this.libConfig.batch_flush_interval_ms, this.stopped = !this.libConfig.batch_autostart, this.consecutiveRemovalFailures = 0, this.itemIdsSentSuccessfully = {}, this.flushOnlyOnInterval = t.flushOnlyOnInterval || !1; }; Or.prototype.enqueue = function (e, t) { this.queue.enqueue(e, this.flushInterval, t); }, Or.prototype.start = function () { this.stopped = !1, this.consecutiveRemovalFailures = 0, this.flush(); }, Or.prototype.stop = function () { this.stopped = !0, this.timeoutID && (clearTimeout(this.timeoutID), this.timeoutID = null); }, Or.prototype.clear = function () { this.queue.clear(); }, Or.prototype.resetBatchSize = function () { this.batchSize = this.libConfig.batch_size; }, Or.prototype.resetFlush = function () { this.scheduleFlush(this.libConfig.batch_flush_interval_ms); }, Or.prototype.scheduleFlush = function (e) { this.flushInterval = e, this.stopped || (this.timeoutID = setTimeout(Ht.bind((function () { this.stopped || this.flush(); }), this), this.flushInterval)); }, Or.prototype.flush = function (e) { try { if (this.requestInProgress) return void Er.log("Flush: Request already in progress"); e = e || {}; var t = this.libConfig.batch_request_timeout_ms, r = (new Date).getTime(), n = this.batchSize, o = this.queue.fillBatch(n), i = o.length === n, s = [], a = {}; if (Ht.each(o, (function (e) { var t = e.payload; if (this.beforeSendHook && !e.orphaned && (t = this.beforeSendHook(t)), t) { t.event && t.properties && (t.properties = Ht.extend({}, t.properties, { mp_sent_by_lib_version: mt.LIB_VERSION })); var r = !0, n = e.id; n ? (this.itemIdsSentSuccessfully[n] || 0) > 5 && (this.reportError("[dupe] item ID sent too many times, not sending", { item: e, batchSize: o.length, timesSent: this.itemIdsSentSuccessfully[n] }), r = !1) : this.reportError("[dupe] found item with no ID", { item: e }), r && s.push(t); } a[e.id] = t; }), this), s.length < 1) return void this.resetFlush(); this.requestInProgress = !0; var c = Ht.bind((function (s) { this.requestInProgress = !1; try { var c = !1; if (e.unloading) this.queue.updatePayloads(a); else if (Ht.isObject(s) && "timeout" === s.error && (new Date).getTime() - r >= t) this.reportError("Network timeout; retrying"), this.flush(); else if (Ht.isObject(s) && (s.httpStatusCode >= 500 || 429 === s.httpStatusCode || "timeout" === s.error)) { var u = 2 * this.flushInterval; s.retryAfter && (u = 1e3 * parseInt(s.retryAfter, 10) || u), u = Math.min(6e5, u), this.reportError("Error; retry in " + u + " ms"), this.scheduleFlush(u); } else if (Ht.isObject(s) && 413 === s.httpStatusCode) if (o.length > 1) { var l = Math.max(1, Math.floor(n / 2)); this.batchSize = Math.min(this.batchSize, l, o.length - 1), this.reportError("413 response; reducing batch size to " + this.batchSize), this.resetFlush(); } else this.reportError("Single-event request too large; dropping", o), this.resetBatchSize(), c = !0; else c = !0; c && (this.queue.removeItemsByID(Ht.map(o, (function (e) { return e.id; })), Ht.bind((function (e) { e ? (this.consecutiveRemovalFailures = 0, this.flushOnlyOnInterval && !i ? this.resetFlush() : this.flush()) : (this.reportError("Failed to remove items from queue"), ++this.consecutiveRemovalFailures > 5 ? (this.reportError("Too many queue failures; disabling batching system."), this.stopAllBatching()) : this.resetFlush()); }), this)), Ht.each(o, Ht.bind((function (e) { var t = e.id; t ? (this.itemIdsSentSuccessfully[t] = this.itemIdsSentSuccessfully[t] || 0, this.itemIdsSentSuccessfully[t]++, this.itemIdsSentSuccessfully[t] > 5 && this.reportError("[dupe] item ID sent too many times", { item: e, batchSize: o.length, timesSent: this.itemIdsSentSuccessfully[t] })) : this.reportError("[dupe] found item with no ID while removing", { item: e }); }), this))); } catch (e) { this.reportError("Error handling API response", e), this.resetFlush(); } }), this), u = { method: "POST", verbose: !0, ignore_json_errors: !0, timeout_ms: t }; e.unloading && (u.transport = "sendBeacon"), Er.log("MIXPANEL REQUEST:", s), this.sendRequest(s, u, c); } catch (e) { this.reportError("Error flushing request queue", e), this.resetFlush(); } }, Or.prototype.reportError = function (e, t) { if (Er.error.apply(Er.error, arguments), this.errorReporter) try { t instanceof Error || (t = new Error(e)), this.errorReporter(e, t); } catch (e) { Er.error(e); } }; var Tr = Qt("recorder"), Rr = pt.CompressionStream, Dr = { batch_size: 1e3, batch_flush_interval_ms: 1e4, batch_request_timeout_ms: 9e4, batch_autostart: !0 }, Nr = new Set([ft.MouseMove, ft.MouseInteraction, ft.Scroll, ft.ViewportResize, ft.Input, ft.TouchMove, ft.MediaInteraction, ft.Drag, ft.Selection]); var Ar = function (e) { this._mixpanel = e, this._stopRecording = null, this.recEvents = [], this.seqNo = 0, this.replayId = null, this.replayStartTime = null, this.sendBatchId = null, this.idleTimeoutId = null, this.maxTimeoutId = null, this.recordMaxMs = xt, this._initBatcher(); }; Ar.prototype._initBatcher = function () { this.batcher = new Or("__mprec", { libConfig: Dr, sendRequestFunc: Ht.bind(this.flushEventsWithOptOut, this), errorReporter: Ht.bind(this.reportError, this), flushOnlyOnInterval: !0, usePersistence: !1 }); }, Ar.prototype.get_config = function (e) { return this._mixpanel.get_config(e); }, Ar.prototype.startRecording = function (e) { if (null === this._stopRecording) { this.recordMaxMs = this.get_config("record_max_ms"), this.recordMaxMs > xt && (this.recordMaxMs = xt, Tr.critical("record_max_ms cannot be greater than " + xt + "ms. Capping value.")), this.recEvents = [], this.seqNo = 0, this.replayStartTime = null, this.replayId = Ht.UUID(), e ? this.batcher.stop() : this.batcher.start(); var t = Ht.bind((function () { clearTimeout(this.idleTimeoutId), this.idleTimeoutId = setTimeout(Ht.bind((function () { Tr.log("Idle timeout reached, restarting recording."), this.resetRecording(); }), this), this.get_config("record_idle_timeout_ms")); }), this); this._stopRecording = lt({ emit: Ht.bind((function (e) { this.batcher.enqueue(e), function (e) { return e.type === ht.IncrementalSnapshot && Nr.has(e.data.source); }(e) && (this.batcher.stopped && this.batcher.start(), t()); }), this), blockClass: this.get_config("record_block_class"), blockSelector: this.get_config("record_block_selector"), collectFonts: this.get_config("record_collect_fonts"), inlineImages: this.get_config("record_inline_images"), maskAllInputs: !0, maskTextClass: this.get_config("record_mask_text_class"), maskTextSelector: this.get_config("record_mask_text_selector") }), t(), this.maxTimeoutId = setTimeout(Ht.bind(this.resetRecording, this), this.recordMaxMs); } else Tr.log("Recording already in progress, skipping startRecording."); }, Ar.prototype.resetRecording = function () { this.stopRecording(), this.startRecording(!0); }, Ar.prototype.stopRecording = function () { null !== this._stopRecording && (this._stopRecording(), this._stopRecording = null), this.batcher.stopped ? this.batcher.clear() : (this.batcher.flush(), this.batcher.stop()), this.replayId = null, clearTimeout(this.idleTimeoutId), clearTimeout(this.maxTimeoutId); }, Ar.prototype.flushEventsWithOptOut = function (e, t, r) { this._flushEvents(e, t, r, Ht.bind(this._onOptOut, this)); }, Ar.prototype._onOptOut = function (e) { 0 === e && (this.recEvents = [], this.stopRecording()); }, Ar.prototype._sendRequest = function (e, t, r) { var n = Ht.bind((function (e, t) { 200 === e.status && this.seqNo++, r({ status: 0, httpStatusCode: e.status, responseBody: t, retryAfter: e.headers.get("Retry-After") }); }), this); pt.fetch(this.get_config("api_host") + "/" + this.get_config("api_routes").record + "?" + new URLSearchParams(e), { method: "POST", headers: { Authorization: "Basic " + btoa(this.get_config("token") + ":"), "Content-Type": "application/octet-stream" }, body: t }).then((function (e) { e.json().then((function (t) { n(e, t); })).catch((function (e) { r({ error: e }); })); })).catch((function (e) { r({ error: e }); })); }, Ar.prototype._flushEvents = hr((function (e, t, r) { const n = e.length; if (n > 0) { var o = e[0].timestamp; 0 === this.seqNo && (this.replayStartTime = o); var i = e[n - 1].timestamp - this.replayStartTime, s = { distinct_id: String(this._mixpanel.get_distinct_id()), seq: this.seqNo, batch_start_time: o / 1e3, replay_id: this.replayId, replay_length_ms: i, replay_start_time: this.replayStartTime / 1e3 }, a = Ht.JSONEncode(e), c = this._mixpanel.get_property("$device_id"); c && (s.$device_id = c); var u = this._mixpanel.get_property("$user_id"); if (u && (s.$user_id = u), Rr) { var l = new Blob([a], { type: "application/json" }).stream().pipeThrough(new Rr("gzip")); new Response(l).blob().then(Ht.bind((function (e) { s.format = "gzip", this._sendRequest(s, e, r); }), this)); } else s.format = "body", this._sendRequest(s, a, r); } })), Ar.prototype.reportError = function (e, t) { Tr.error.apply(Tr.error, arguments); try { t || e instanceof Error || (e = new Error(e)), this.get_config("error_reporter")(e, t); } catch (e) { Tr.error(e); } }, pt.__mp_recorder = Ar; var Lr = function () { }; Lr.prototype.create_properties = function () { }, Lr.prototype.event_handler = function () { }, Lr.prototype.after_track_handler = function () { }, Lr.prototype.init = function (e) { return this.mp = e, this; }, Lr.prototype.track = function (e, t, r, n) { var o = this, i = Ht.dom_query(e); if (0 !== i.length) return Ht.each(i, (function (e) { Ht.register_event(e, this.override_event, (function (e) { var i = {}, s = o.create_properties(r, this), a = o.mp.get_config("track_links_timeout"); o.event_handler(e, this, i), window.setTimeout(o.track_callback(n, s, i, !0), a), o.mp.track(t, s, o.track_callback(n, s, i)); })); }), this), !0; Gt.error("The DOM query (" + e + ") returned 0 elements"); }, Lr.prototype.track_callback = function (e, t, r, n) { n = n || !1; var o = this; return function () { r.callback_fired || (r.callback_fired = !0, e && !1 === e(n, t) || o.after_track_handler(t, r, n)); }; }, Lr.prototype.create_properties = function (e, t) { return "function" == typeof e ? e(t) : Ht.extend({}, e); }; var qr = function () { this.override_event = "click"; }; Ht.inherit(qr, Lr), qr.prototype.create_properties = function (e, t) { var r = qr.superclass.create_properties.apply(this, arguments); return t.href && (r.url = t.href), r; }, qr.prototype.event_handler = function (e, t, r) { r.new_tab = 2 === e.which || e.metaKey || e.ctrlKey || "_blank" === t.target, r.href = t.href, r.new_tab || e.preventDefault(); }, qr.prototype.after_track_handler = function (e, t) { t.new_tab || setTimeout((function () { window.location = t.href; }), 0); }; var Fr = function () { this.override_event = "submit"; }; Ht.inherit(Fr, Lr), Fr.prototype.event_handler = function (e, t, r) { r.element = t, e.preventDefault(); }, Fr.prototype.after_track_handler = function (e, t) { setTimeout((function () { t.element.submit(); }), 0); }; var Pr = "$set", Ur = "$set_once", jr = "$unset", Br = "$add", $r = "$append", zr = "$union", Wr = "$remove", Vr = { set_action: function (e, t) { var r = {}, n = {}; return Ht.isObject(e) ? Ht.each(e, (function (e, t) { this._is_reserved_property(t) || (n[t] = e); }), this) : n[e] = t, r[Pr] = n, r; }, unset_action: function (e) { var t = {}, r = []; return Ht.isArray(e) || (e = [e]), Ht.each(e, (function (e) { this._is_reserved_property(e) || r.push(e); }), this), t[jr] = r, t; }, set_once_action: function (e, t) { var r = {}, n = {}; return Ht.isObject(e) ? Ht.each(e, (function (e, t) { this._is_reserved_property(t) || (n[t] = e); }), this) : n[e] = t, r[Ur] = n, r; }, union_action: function (e, t) { var r = {}, n = {}; return Ht.isObject(e) ? Ht.each(e, (function (e, t) { this._is_reserved_property(t) || (n[t] = Ht.isArray(e) ? e : [e]); }), this) : n[e] = Ht.isArray(t) ? t : [t], r[zr] = n, r; }, append_action: function (e, t) { var r = {}, n = {}; return Ht.isObject(e) ? Ht.each(e, (function (e, t) { this._is_reserved_property(t) || (n[t] = e); }), this) : n[e] = t, r[$r] = n, r; }, remove_action: function (e, t) { var r = {}, n = {}; return Ht.isObject(e) ? Ht.each(e, (function (e, t) { this._is_reserved_property(t) || (n[t] = e); }), this) : n[e] = t, r[Wr] = n, r; }, delete_action: function () { var e = { $delete: "" }; return e; } }, Hr = function () { }; Ht.extend(Hr.prototype, Vr), Hr.prototype._init = function (e, t, r) { this._mixpanel = e, this._group_key = t, this._group_id = r; }, Hr.prototype.set = mr((function (e, t, r) { var n = this.set_action(e, t); return Ht.isObject(e) && (r = t), this._send_request(n, r); })), Hr.prototype.set_once = mr((function (e, t, r) { var n = this.set_once_action(e, t); return Ht.isObject(e) && (r = t), this._send_request(n, r); })), Hr.prototype.unset = mr((function (e, t) { var r = this.unset_action(e); return this._send_request(r, t); })), Hr.prototype.union = mr((function (e, t, r) { Ht.isObject(e) && (r = t); var n = this.union_action(e, t); return this._send_request(n, r); })), Hr.prototype.delete = mr((function (e) { var t = this.delete_action(); return this._send_request(t, e); })), Hr.prototype.remove = mr((function (e, t, r) { var n = this.remove_action(e, t); return this._send_request(n, r); })), Hr.prototype._send_request = function (e, t) { e.$group_key = this._group_key, e.$group_id = this._group_id, e.$token = this._get_config("token"); var r = Ht.encodeDates(e); return this._mixpanel._track_or_batch({ type: "groups", data: r, endpoint: this._get_config("api_host") + "/" + this._get_config("api_routes").groups, batcher: this._mixpanel.request_batchers.groups }, t); }, Hr.prototype._is_reserved_property = function (e) { return "$group_key" === e || "$group_id" === e; }, Hr.prototype._get_config = function (e) { return this._mixpanel.get_config(e); }, Hr.prototype.toString = function () { return this._mixpanel.toString() + ".group." + this._group_key + "." + this._group_id; }, Hr.prototype.remove = Hr.prototype.remove, Hr.prototype.set = Hr.prototype.set, Hr.prototype.set_once = Hr.prototype.set_once, Hr.prototype.union = Hr.prototype.union, Hr.prototype.unset = Hr.prototype.unset, Hr.prototype.toString = Hr.prototype.toString; var Gr = function () { }; Ht.extend(Gr.prototype, Vr), Gr.prototype._init = function (e) { this._mixpanel = e; }, Gr.prototype.set = fr((function (e, t, r) { var n = this.set_action(e, t); return Ht.isObject(e) && (r = t), this._get_config("save_referrer") && this._mixpanel.persistence.update_referrer_info(document.referrer), n[Pr] = Ht.extend({}, Ht.info.people_properties(), n[Pr]), this._send_request(n, r); })), Gr.prototype.set_once = fr((function (e, t, r) { var n = this.set_once_action(e, t); return Ht.isObject(e) && (r = t), this._send_request(n, r); })), Gr.prototype.unset = fr((function (e, t) { var r = this.unset_action(e); return this._send_request(r, t); })), Gr.prototype.increment = fr((function (e, t, r) { var n = {}, o = {}; return Ht.isObject(e) ? (Ht.each(e, (function (e, t) { if (!this._is_reserved_property(t)) { if (isNaN(parseFloat(e))) return void Gt.error("Invalid increment value passed to mixpanel.people.increment - must be a number"); o[t] = e; } }), this), r = t) : (Ht.isUndefined(t) && (t = 1), o[e] = t), n[Br] = o, this._send_request(n, r); })), Gr.prototype.append = fr((function (e, t, r) { Ht.isObject(e) && (r = t); var n = this.append_action(e, t); return this._send_request(n, r); })), Gr.prototype.remove = fr((function (e, t, r) { Ht.isObject(e) && (r = t); var n = this.remove_action(e, t); return this._send_request(n, r); })), Gr.prototype.union = fr((function (e, t, r) { Ht.isObject(e) && (r = t); var n = this.union_action(e, t); return this._send_request(n, r); })), Gr.prototype.track_charge = fr((function (e, t, r) { if (Ht.isNumber(e) || (e = parseFloat(e), !isNaN(e))) return this.append("$transactions", Ht.extend({ $amount: e }, t), r); Gt.error("Invalid value passed to mixpanel.people.track_charge - must be a number"); })), Gr.prototype.clear_charges = function (e) { return this.set("$transactions", [], e); }, Gr.prototype.delete_user = function () { if (this._identify_called()) { var e = { $delete: this._mixpanel.get_distinct_id() }; return this._send_request(e); } Gt.error("mixpanel.people.delete_user() requires you to call identify() first"); }, Gr.prototype.toString = function () { return this._mixpanel.toString() + ".people"; }, Gr.prototype._send_request = function (e, t) { e.$token = this._get_config("token"), e.$distinct_id = this._mixpanel.get_distinct_id(); var r = this._mixpanel.get_property("$device_id"), n = this._mixpanel.get_property("$user_id"), o = this._mixpanel.get_property("$had_persisted_distinct_id"); r && (e.$device_id = r), n && (e.$user_id = n), o && (e.$had_persisted_distinct_id = o); var i = Ht.encodeDates(e); return this._identify_called() ? this._mixpanel._track_or_batch({ type: "people", data: i, endpoint: this._get_config("api_host") + "/" + this._get_config("api_routes").engage, batcher: this._mixpanel.request_batchers.people }, t) : (this._enqueue(e), Ht.isUndefined(t) || (this._get_config("verbose") ? t({ status: -1, error: null }) : t(-1)), Ht.truncate(i, 255)); }, Gr.prototype._get_config = function (e) { return this._mixpanel.get_config(e); }, Gr.prototype._identify_called = function () { return !0 === this._mixpanel._flags.identify_called; }, Gr.prototype._enqueue = function (e) { Pr in e ? this._mixpanel.persistence._add_to_people_queue(Pr, e) : Ur in e ? this._mixpanel.persistence._add_to_people_queue(Ur, e) : jr in e ? this._mixpanel.persistence._add_to_people_queue(jr, e) : Br in e ? this._mixpanel.persistence._add_to_people_queue(Br, e) : $r in e ? this._mixpanel.persistence._add_to_people_queue($r, e) : Wr in e ? this._mixpanel.persistence._add_to_people_queue(Wr, e) : zr in e ? this._mixpanel.persistence._add_to_people_queue(zr, e) : Gt.error("Invalid call to _enqueue():", e); }, Gr.prototype._flush_one_queue = function (e, t, r, n) { var o = this, i = Ht.extend({}, this._mixpanel.persistence.load_queue(e)), s = i; Ht.isUndefined(i) || !Ht.isObject(i) || Ht.isEmptyObject(i) || (o._mixpanel.persistence._pop_from_people_queue(e, i), o._mixpanel.persistence.save(), n && (s = n(i)), t.call(o, s, (function (t, n) { 0 === t && o._mixpanel.persistence._add_to_people_queue(e, i), Ht.isUndefined(r) || r(t, n); }))); }, Gr.prototype._flush = function (e, t, r, n, o, i, s) { var a = this; this._flush_one_queue(Pr, this.set, e), this._flush_one_queue(Ur, this.set_once, n), this._flush_one_queue(jr, this.unset, i, (function (e) { return Ht.keys(e); })), this._flush_one_queue(Br, this.increment, t), this._flush_one_queue(zr, this.union, o); var c = this._mixpanel.persistence.load_queue($r); if (!Ht.isUndefined(c) && Ht.isArray(c) && c.length) for (var u, l = function (e, t) { 0 === e && a._mixpanel.persistence._add_to_people_queue($r, u), Ht.isUndefined(r) || r(e, t); }, p = c.length - 1; p >= 0; p--)c = this._mixpanel.persistence.load_queue($r), u = c.pop(), a._mixpanel.persistence.save(), Ht.isEmptyObject(u) || a.append(u, l); var d = this._mixpanel.persistence.load_queue(Wr); if (!Ht.isUndefined(d) && Ht.isArray(d) && d.length) for (var h, f = function (e, t) { 0 === e && a._mixpanel.persistence._add_to_people_queue(Wr, h), Ht.isUndefined(s) || s(e, t); }, m = d.length - 1; m >= 0; m--)d = this._mixpanel.persistence.load_queue(Wr), h = d.pop(), a._mixpanel.persistence.save(), Ht.isEmptyObject(h) || a.remove(h, f); }, Gr.prototype._is_reserved_property = function (e) { return "$distinct_id" === e || "$token" === e || "$device_id" === e || "$user_id" === e || "$had_persisted_distinct_id" === e; }, Gr.prototype.set = Gr.prototype.set, Gr.prototype.set_once = Gr.prototype.set_once, Gr.prototype.unset = Gr.prototype.unset, Gr.prototype.increment = Gr.prototype.increment, Gr.prototype.append = Gr.prototype.append, Gr.prototype.remove = Gr.prototype.remove, Gr.prototype.union = Gr.prototype.union, Gr.prototype.track_charge = Gr.prototype.track_charge, Gr.prototype.clear_charges = Gr.prototype.clear_charges, Gr.prototype.delete_user = Gr.prototype.delete_user, Gr.prototype.toString = Gr.prototype.toString; var Jr, Qr = "__mps", Kr = "__mpso", Xr = "__mpus", Yr = "__mpa", Zr = "__mpap", en = "__mpr", tn = "__mpu", rn = "$people_distinct_id", nn = "__alias", on = "__timers", sn = [Qr, Kr, Xr, Yr, Zr, en, tn, rn, nn, on], an = function (e) { this.props = {}, this.campaign_params_saved = !1, e.persistence_name ? this.name = "mp_" + e.persistence_name : this.name = "mp_" + e.token + "_mixpanel"; var t = e.persistence; "cookie" !== t && "localStorage" !== t && (Gt.critical("Unknown persistence type " + t + "; falling back to cookie"), t = e.persistence = "cookie"), "localStorage" === t && Ht.localStorage.is_supported() ? this.storage = Ht.localStorage : this.storage = Ht.cookie, this.load(), this.update_config(e), this.upgrade(), this.save(); }; an.prototype.properties = function () { var e = {}; return this.load(), Ht.each(this.props, (function (t, r) { Ht.include(sn, r) || (e[r] = t); })), e; }, an.prototype.load = function () { if (!this.disabled) { var e = this.storage.parse(this.name); e && (this.props = Ht.extend({}, e)); } }, an.prototype.upgrade = function () { var e, t; this.storage === Ht.localStorage ? (e = Ht.cookie.parse(this.name), Ht.cookie.remove(this.name), Ht.cookie.remove(this.name, !0), e && this.register_once(e)) : this.storage === Ht.cookie && (t = Ht.localStorage.parse(this.name), Ht.localStorage.remove(this.name), t && this.register_once(t)); }, an.prototype.save = function () { this.disabled || this.storage.set(this.name, Ht.JSONEncode(this.props), this.expire_days, this.cross_subdomain, this.secure, this.cross_site, this.cookie_domain); }, an.prototype.load_prop = function (e) { return this.load(), this.props[e]; }, an.prototype.remove = function () { this.storage.remove(this.name, !1, this.cookie_domain), this.storage.remove(this.name, !0, this.cookie_domain); }, an.prototype.clear = function () { this.remove(), this.props = {}; }, an.prototype.register_once = function (e, t, r) { return !!Ht.isObject(e) && (void 0 === t && (t = "None"), this.expire_days = void 0 === r ? this.default_expiry : r, this.load(), Ht.each(e, (function (e, r) { this.props.hasOwnProperty(r) && this.props[r] !== t || (this.props[r] = e); }), this), this.save(), !0); }, an.prototype.register = function (e, t) { return !!Ht.isObject(e) && (this.expire_days = void 0 === t ? this.default_expiry : t, this.load(), Ht.extend(this.props, e), this.save(), !0); }, an.prototype.unregister = function (e) { this.load(), e in this.props && (delete this.props[e], this.save()); }, an.prototype.update_search_keyword = function (e) { this.register(Ht.info.searchInfo(e)); }, an.prototype.update_referrer_info = function (e) { this.register_once({ $initial_referrer: e || "$direct", $initial_referring_domain: Ht.info.referringDomain(e) || "$direct" }, ""); }, an.prototype.get_referrer_info = function () { return Ht.strip_empty_properties({ $initial_referrer: this.props.$initial_referrer, $initial_referring_domain: this.props.$initial_referring_domain }); }, an.prototype.update_config = function (e) { this.default_expiry = this.expire_days = e.cookie_expiration, this.set_disabled(e.disable_persistence), this.set_cookie_domain(e.cookie_domain), this.set_cross_site(e.cross_site_cookie), this.set_cross_subdomain(e.cross_subdomain_cookie), this.set_secure(e.secure_cookie); }, an.prototype.set_disabled = function (e) { this.disabled = e, this.disabled ? this.remove() : this.save(); }, an.prototype.set_cookie_domain = function (e) { e !== this.cookie_domain && (this.remove(), this.cookie_domain = e, this.save()); }, an.prototype.set_cross_site = function (e) { e !== this.cross_site && (this.cross_site = e, this.remove(), this.save()); }, an.prototype.set_cross_subdomain = function (e) { e !== this.cross_subdomain && (this.cross_subdomain = e, this.remove(), this.save()); }, an.prototype.get_cross_subdomain = function () { return this.cross_subdomain; }, an.prototype.set_secure = function (e) { e !== this.secure && (this.secure = !!e, this.remove(), this.save()); }, an.prototype._add_to_people_queue = function (e, t) { var r = this._get_queue_key(e), n = t[e], o = this._get_or_create_queue(Pr), i = this._get_or_create_queue(Ur), s = this._get_or_create_queue(jr), a = this._get_or_create_queue(Br), c = this._get_or_create_queue(zr), u = this._get_or_create_queue(Wr, []), l = this._get_or_create_queue($r, []); r === Qr ? (Ht.extend(o, n), this._pop_from_people_queue(Br, n), this._pop_from_people_queue(zr, n), this._pop_from_people_queue(jr, n)) : r === Kr ? (Ht.each(n, (function (e, t) { t in i || (i[t] = e); })), this._pop_from_people_queue(jr, n)) : r === Xr ? Ht.each(n, (function (e) { Ht.each([o, i, a, c], (function (t) { e in t && delete t[e]; })), Ht.each(l, (function (t) { e in t && delete t[e]; })), s[e] = !0; })) : r === Yr ? (Ht.each(n, (function (e, t) { t in o ? o[t] += e : (t in a || (a[t] = 0), a[t] += e); }), this), this._pop_from_people_queue(jr, n)) : r === tn ? (Ht.each(n, (function (e, t) { Ht.isArray(e) && (t in c || (c[t] = []), c[t] = c[t].concat(e)); })), this._pop_from_people_queue(jr, n)) : r === en ? (u.push(n), this._pop_from_people_queue($r, n)) : r === Zr && (l.push(n), this._pop_from_people_queue(jr, n)), Gt.log("MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):"), Gt.log(t), this.save(); }, an.prototype._pop_from_people_queue = function (e, t) { var r = this.props[this._get_queue_key(e)]; Ht.isUndefined(r) || Ht.each(t, (function (t, n) { e === $r || e === Wr ? Ht.each(r, (function (e) { e[n] === t && delete e[n]; })) : delete r[n]; }), this); }, an.prototype.load_queue = function (e) { return this.load_prop(this._get_queue_key(e)); }, an.prototype._get_queue_key = function (e) { return e === Pr ? Qr : e === Ur ? Kr : e === jr ? Xr : e === Br ? Yr : e === $r ? Zr : e === Wr ? en : e === zr ? tn : void Gt.error("Invalid queue:", e); }, an.prototype._get_or_create_queue = function (e, t) { var r = this._get_queue_key(e); return t = Ht.isUndefined(t) ? {} : t, this.props[r] || (this.props[r] = t); }, an.prototype.set_event_timer = function (e, t) { var r = this.load_prop(on) || {}; r[e] = t, this.props[on] = r, this.save(); }, an.prototype.remove_event_timer = function (e) { var t = (this.load_prop(on) || {})[e]; return Ht.isUndefined(t) || (delete this.props[on][e], this.save()), t; }; var cn, un = function (e, t) { throw new Error(e + " not available in this build."); }, ln = function (e) { return e; }, pn = function () { }, dn = "mixpanel", hn = "base64", fn = "$device:", mn = pt.XMLHttpRequest && "withCredentials" in new XMLHttpRequest, _n = !mn && -1 === Ut.indexOf("MSIE") && -1 === Ut.indexOf("Mozilla"), gn = null; Lt.sendBeacon && (gn = function () { return Lt.sendBeacon.apply(Lt, arguments); }); var yn = { track: "track/", engage: "engage/", groups: "groups/", record: "record/" }, vn = { api_host: "https://api-js.mixpanel.com", api_routes: yn, api_method: "POST", api_transport: "XHR", api_payload_format: hn, app_host: "https://mixpanel.com", cdn: "https://cdn.mxpnl.com", cross_site_cookie: !1, cross_subdomain_cookie: !0, error_reporter: pn, persistence: "cookie", persistence_name: "", cookie_domain: "", cookie_name: "", loaded: pn, mp_loader: null, track_marketing: !0, track_pageview: !1, skip_first_touch_marketing: !1, store_google: !0, stop_utm_persistence: !1, save_referrer: !0, test: !1, verbose: !1, img: !1, debug: !1, track_links_timeout: 300, cookie_expiration: 365, upgrade: !1, disable_persistence: !1, disable_cookie: !1, secure_cookie: !1, ip: !0, opt_out_tracking_by_default: !1, opt_out_persistence_by_default: !1, opt_out_tracking_persistence_type: "localStorage", opt_out_tracking_cookie_prefix: null, property_blacklist: [], xhr_headers: {}, ignore_dnt: !1, batch_requests: !0, batch_size: 50, batch_flush_interval_ms: 5e3, batch_request_timeout_ms: 9e4, batch_autostart: !0, hooks: {}, record_block_class: new RegExp("^(mp-block|fs-exclude|amp-block|rr-block|ph-no-capture)$"), record_block_selector: "img, video", record_collect_fonts: !1, record_idle_timeout_ms: 18e5, record_inline_images: !1, record_mask_text_class: new RegExp("^(mp-mask|fs-mask|amp-mask|rr-mask|ph-mask)$"), record_mask_text_selector: "*", record_max_ms: xt, record_sessions_percent: 0, recorder_src: "https://cdn.mxpnl.com/libs/mixpanel-recorder.min.js" }, bn = !1, Sn = function () { }, kn = function (e, t, r) { var n, o = r === dn ? cn : cn[r]; if (o && 0 === Jr) n = o; else { if (o && !Ht.isArray(o)) return void Gt.error("You have already initialized " + r); n = new Sn; } if (n._cached_groups = {}, n._init(e, t, r), n.people = new Gr, n.people._init(n), !n.get_config("skip_first_touch_marketing")) { var i = Ht.info.campaignParams(null), s = {}, a = !1; Ht.each(i, (function (e, t) { s["initial_" + t] = e, e && (a = !0); })), a && n.people.set_once(s); } return mt.DEBUG = mt.DEBUG || n.get_config("debug"), !Ht.isUndefined(o) && Ht.isArray(o) && (n._execute_array.call(n.people, o.people), n._execute_array(o)), n; }; Sn.prototype.init = function (e, t, r) { if (Ht.isUndefined(r)) this.report_error("You must name your new library: init(token, config, name)"); else { if (r !== dn) { var n = kn(e, t, r); return cn[r] = n, n._loaded(), n; } this.report_error("You must initialize the main mixpanel object right after you include the Mixpanel js snippet"); } }, Sn.prototype._init = function (e, t, r) { t = t || {}, this.__loaded = !0, this.config = {}; var n = {}; "api_payload_format" in t || (t.api_host || vn.api_host).match(/\.mixpanel\.com/) && (n.api_payload_format = "json"); if (this.set_config(Ht.extend({}, vn, n, t, { name: r, token: e, callback_fn: (r === dn ? r : dn + "." + r) + "._jsc" })), this._jsc = pn, this.__dom_loaded_queue = [], this.__request_queue = [], this.__disabled_events = [], this._flags = { disable_all_events: !1, identify_called: !1 }, this.request_batchers = {}, this._batch_requests = this.get_config("batch_requests"), this._batch_requests) if (Ht.localStorage.is_supported(!0) && mn) { if (this.init_batchers(), gn && pt.addEventListener) { var o = Ht.bind((function () { this.request_batchers.events.stopped || this.request_batchers.events.flush({ unloading: !0 }); }), this); pt.addEventListener("pagehide", (function (e) { e.persisted && o(); })), pt.addEventListener("visibilitychange", (function () { "hidden" === qt.visibilityState && o(); })); } } else this._batch_requests = !1, Gt.log("Turning off Mixpanel request-queueing; needs XHR and localStorage support"), Ht.each(this.get_batcher_configs(), (function (e) { Gt.log("Clearing batch queue " + e.queue_key), Ht.localStorage.remove(e.queue_key); })); this.persistence = this.cookie = new an(this.config), this.unpersisted_superprops = {}, this._gdpr_init(); var i = Ht.UUID(); this.get_distinct_id() || this.register_once({ distinct_id: fn + i, $device_id: i }, ""); var s = this.get_config("track_pageview"); s && this._init_url_change_tracking(s), this.get_config("record_sessions_percent") > 0 && 100 * Math.random() <= this.get_config("record_sessions_percent") && this.start_session_recording(); }, Sn.prototype.start_session_recording = hr((function () { if (pt.MutationObserver) { var e = Ht.bind((function () { this._recorder = this._recorder || new pt.__mp_recorder(this), this._recorder.startRecording(); }), this); Ht.isUndefined(pt.__mp_recorder) ? un(this.get_config("recorder_src"), e) : e(); } else Gt.critical("Browser does not support MutationObserver; skipping session recording"); })), Sn.prototype.stop_session_recording = function () { this._recorder ? this._recorder.stopRecording() : Gt.critical("Session recorder module not loaded"); }, Sn.prototype.get_session_recording_properties = function () { var e = {}; if (this._recorder) { var t = this._recorder.replayId; t && (e.$mp_replay_id = t); } return e; }, Sn.prototype._loaded = function () { if (this.get_config("loaded")(this), this._set_default_superprops(), this.people.set_once(this.persistence.get_referrer_info()), this.get_config("store_google") && this.get_config("stop_utm_persistence")) { var e = Ht.info.campaignParams(null); Ht.each(e, function (e, t) { this.unregister(t); }.bind(this)); } }, Sn.prototype._set_default_superprops = function () { this.persistence.update_search_keyword(qt.referrer), this.get_config("store_google") && !this.get_config("stop_utm_persistence") && this.register(Ht.info.campaignParams()), this.get_config("save_referrer") && this.persistence.update_referrer_info(qt.referrer); }, Sn.prototype._dom_loaded = function () { Ht.each(this.__dom_loaded_queue, (function (e) { this._track_dom.apply(this, e); }), this), this.has_opted_out_tracking() || Ht.each(this.__request_queue, (function (e) { this._send_request.apply(this, e); }), this), delete this.__dom_loaded_queue, delete this.__request_queue; }, Sn.prototype._track_dom = function (e, t) { if (this.get_config("img")) return this.report_error("You can't use DOM tracking functions with img = true."), !1; if (!bn) return this.__dom_loaded_queue.push([e, t]), !1; var r = (new e).init(this); return r.track.apply(r, t); }, Sn.prototype._init_url_change_tracking = function (e) { var t = ""; if (this.track_pageview() && (t = Ht.info.currentUrl()), Ht.include(["full-url", "url-with-path-and-query-string", "url-with-path"], e)) { pt.addEventListener("popstate", (function () { pt.dispatchEvent(new Event("mp_locationchange")); })), pt.addEventListener("hashchange", (function () { pt.dispatchEvent(new Event("mp_locationchange")); })); var r = pt.history.pushState; "function" == typeof r && (pt.history.pushState = function (e, t, n) { r.call(pt.history, e, t, n), pt.dispatchEvent(new Event("mp_locationchange")); }); var n = pt.history.replaceState; "function" == typeof n && (pt.history.replaceState = function (e, t, r) { n.call(pt.history, e, t, r), pt.dispatchEvent(new Event("mp_locationchange")); }), pt.addEventListener("mp_locationchange", function () { var r = Ht.info.currentUrl(), n = !1; ("full-url" === e ? n = r !== t : "url-with-path-and-query-string" === e ? n = r.split("#")[0] !== t.split("#")[0] : "url-with-path" === e && (n = r.split("#")[0].split("?")[0] !== t.split("#")[0].split("?")[0]), n) && (this.track_pageview() && (t = r)); }.bind(this)); } }, Sn.prototype._prepare_callback = function (e, t) { if (Ht.isUndefined(e)) return null; if (mn) { return function (r) { e(r, t); }; } var r = this._jsc, n = "" + Math.floor(1e8 * Math.random()), o = this.get_config("callback_fn") + "[" + n + "]"; return r[n] = function (o) { delete r[n], e(o, t); }, o; }, Sn.prototype._send_request = function (e, t, r, n) { var o = !0; if (_n) return this.__request_queue.push(arguments), o; var i = { method: this.get_config("api_method"), transport: this.get_config("api_transport"), verbose: this.get_config("verbose") }, s = null; n || !Ht.isFunction(r) && "string" != typeof r || (n = r, r = null), r = Ht.extend(i, r || {}), mn || (r.method = "GET"); var a = "POST" === r.method, c = gn && a && "sendbeacon" === r.transport.toLowerCase(), u = r.verbose; t.verbose && (u = !0), this.get_config("test") && (t.test = 1), u && (t.verbose = 1), this.get_config("img") && (t.img = 1), mn || (n ? t.callback = n : (u || this.get_config("test")) && (t.callback = "(function(){})")), t.ip = this.get_config("ip") ? 1 : 0, t._ = (new Date).getTime().toString(), a && (s = "data=" + encodeURIComponent(t.data), delete t.data), e += "?" + Ht.HTTPBuildQuery(t); var l = this; if ("img" in t) { var p = qt.createElement("img"); p.src = e, qt.body.appendChild(p); } else if (c) { try { o = gn(e, s); } catch (e) { l.report_error(e), o = !1; } try { n && n(o ? 1 : 0); } catch (e) { l.report_error(e); } } else if (mn) try { var d = new XMLHttpRequest; d.open(r.method, e, !0); var h = this.get_config("xhr_headers"); if (a && (h["Content-Type"] = "application/x-www-form-urlencoded"), Ht.each(h, (function (e, t) { d.setRequestHeader(t, e); })), r.timeout_ms && void 0 !== d.timeout) { d.timeout = r.timeout_ms; var f = (new Date).getTime(); } d.withCredentials = !0, d.onreadystatechange = function () { var e; if (4 === d.readyState) if (200 === d.status) { if (n) if (u) { var t; try { t = Ht.JSONDecode(d.responseText); } catch (e) { if (l.report_error(e), !r.ignore_json_errors) return; t = d.responseText; } n(t); } else n(Number(d.responseText)); } else if (e = d.timeout && !d.status && (new Date).getTime() - f >= d.timeout ? "timeout" : "Bad HTTP status: " + d.status + " " + d.statusText, l.report_error(e), n) if (u) { var o = d.responseHeaders || {}; n({ status: 0, httpStatusCode: d.status, error: e, retryAfter: o["Retry-After"] }); } else n(0); }, d.send(s); } catch (e) { l.report_error(e), o = !1; } else { var m = qt.createElement("script"); m.type = "text/javascript", m.async = !0, m.defer = !0, m.src = e; var _ = qt.getElementsByTagName("script")[0]; _.parentNode.insertBefore(m, _); } return o; }, Sn.prototype._execute_array = function (e) { var t, r = [], n = [], o = []; Ht.each(e, (function (e) { e && (t = e[0], Ht.isArray(t) ? o.push(e) : "function" == typeof e ? e.call(this) : Ht.isArray(e) && "alias" === t ? r.push(e) : Ht.isArray(e) && -1 !== t.indexOf("track") && "function" == typeof this[t] ? o.push(e) : n.push(e)); }), this); var i = function (e, t) { Ht.each(e, (function (e) { if (Ht.isArray(e[0])) { var r = t; Ht.each(e, (function (e) { r = r[e[0]].apply(r, e.slice(1)); })); } else this[e[0]].apply(this, e.slice(1)); }), t); }; i(r, this), i(n, this), i(o, this); }, Sn.prototype.are_batchers_initialized = function () { return !!this.request_batchers.events; }, Sn.prototype.get_batcher_configs = function () { var e = "__mpq_" + this.get_config("token"), t = this.get_config("api_routes"); return this._batcher_configs = this._batcher_configs || { events: { type: "events", endpoint: "/" + t.track, queue_key: e + "_ev" }, people: { type: "people", endpoint: "/" + t.engage, queue_key: e + "_pp" }, groups: { type: "groups", endpoint: "/" + t.groups, queue_key: e + "_gr" } }, this._batcher_configs; }, Sn.prototype.init_batchers = function () { if (!this.are_batchers_initialized()) { var e = Ht.bind((function (e) { return new Or(e.queue_key, { libConfig: this.config, errorReporter: this.get_config("error_reporter"), sendRequestFunc: Ht.bind((function (t, r, n) { this._send_request(this.get_config("api_host") + e.endpoint, this._encode_data_for_request(t), r, this._prepare_callback(n, t)); }), this), beforeSendHook: Ht.bind((function (t) { return this._run_hook("before_send_" + e.type, t); }), this), stopAllBatchingFunc: Ht.bind(this.stop_batch_senders, this), usePersistence: !0 }); }), this), t = this.get_batcher_configs(); this.request_batchers = { events: e(t.events), people: e(t.people), groups: e(t.groups) }; } this.get_config("batch_autostart") && this.start_batch_senders(); }, Sn.prototype.start_batch_senders = function () { this._batchers_were_started = !0, this.are_batchers_initialized() && (this._batch_requests = !0, Ht.each(this.request_batchers, (function (e) { e.start(); }))); }, Sn.prototype.stop_batch_senders = function () { this._batch_requests = !1, Ht.each(this.request_batchers, (function (e) { e.stop(), e.clear(); })); }, Sn.prototype.push = function (e) { this._execute_array([e]); }, Sn.prototype.disable = function (e) { void 0 === e ? this._flags.disable_all_events = !0 : this.__disabled_events = this.__disabled_events.concat(e); }, Sn.prototype._encode_data_for_request = function (e) { var t = Ht.JSONEncode(e); return this.get_config("api_payload_format") === hn && (t = Ht.base64Encode(t)), { data: t }; }, Sn.prototype._track_or_batch = function (e, t) { var r = Ht.truncate(e.data, 255), n = e.endpoint, o = e.batcher, i = e.should_send_immediately, s = e.send_request_options || {}; t = t || pn; var a = !0, c = Ht.bind((function () { return s.skip_hooks || (r = this._run_hook("before_send_" + e.type, r)), r ? (Gt.log("MIXPANEL REQUEST:"), Gt.log(r), this._send_request(n, this._encode_data_for_request(r), s, this._prepare_callback(t, r))) : null; }), this); return this._batch_requests && !i ? o.enqueue(r, (function (e) { e ? t(1, r) : c(); })) : a = c(), a && r; }, Sn.prototype.track = hr((function (e, t, r, n) { n || "function" != typeof r || (n = r, r = null); var o = (r = r || {}).transport; o && (r.transport = o); var i = r.send_immediately; if ("function" != typeof n && (n = pn), Ht.isUndefined(e)) this.report_error("No event name provided to mixpanel.track"); else { if (!this._event_is_disabled(e)) { (t = Ht.extend({}, t)).token = this.get_config("token"); var s = this.persistence.remove_event_timer(e); if (!Ht.isUndefined(s)) { var a = (new Date).getTime() - s; t.$duration = parseFloat((a / 1e3).toFixed(3)); } this._set_default_superprops(); var c = this.get_config("track_marketing") ? Ht.info.marketingParams() : {}; t = Ht.extend({}, Ht.info.properties({ mp_loader: this.get_config("mp_loader") }), c, this.persistence.properties(), this.unpersisted_superprops, this.get_session_recording_properties(), t); var u = this.get_config("property_blacklist"); Ht.isArray(u) ? Ht.each(u, (function (e) { delete t[e]; })) : this.report_error("Invalid value for property_blacklist config: " + u); var l = { event: e, properties: t }; return this._track_or_batch({ type: "events", data: l, endpoint: this.get_config("api_host") + "/" + this.get_config("api_routes").track, batcher: this.request_batchers.events, should_send_immediately: i, send_request_options: r }, n); } n(0); } })), Sn.prototype.set_group = hr((function (e, t, r) { Ht.isArray(t) || (t = [t]); var n = {}; return n[e] = t, this.register(n), this.people.set(e, t, r); })), Sn.prototype.add_group = hr((function (e, t, r) { var n = this.get_property(e), o = {}; return void 0 === n ? (o[e] = [t], this.register(o)) : -1 === n.indexOf(t) && (n.push(t), o[e] = n, this.register(o)), this.people.union(e, t, r); })), Sn.prototype.remove_group = hr((function (e, t, r) { var n = this.get_property(e); if (void 0 !== n) { var o = n.indexOf(t); o > -1 && (n.splice(o, 1), this.register({ group_key: n })), 0 === n.length && this.unregister(e); } return this.people.remove(e, t, r); })), Sn.prototype.track_with_groups = hr((function (e, t, r, n) { var o = Ht.extend({}, t || {}); return Ht.each(r, (function (e, t) { null != e && (o[t] = e); })), this.track(e, o, n); })), Sn.prototype._create_map_key = function (e, t) { return e + "_" + JSON.stringify(t); }, Sn.prototype._remove_group_from_cache = function (e, t) { delete this._cached_groups[this._create_map_key(e, t)]; }, Sn.prototype.get_group = function (e, t) { var r = this._create_map_key(e, t), n = this._cached_groups[r]; return void 0 !== n && n._group_key === e && n._group_id === t || ((n = new Hr)._init(this, e, t), this._cached_groups[r] = n), n; }, Sn.prototype.track_pageview = hr((function (e, t) { "object" != typeof e && (e = {}); var r = (t = t || {}).event_name || "$mp_web_page_view", n = Ht.extend(Ht.info.mpPageViewProperties(), Ht.info.campaignParams(), Ht.info.clickParams()), o = Ht.extend({}, n, e); return this.track(r, o); })), Sn.prototype.track_links = function () { return this._track_dom.call(this, qr, arguments); }, Sn.prototype.track_forms = function () { return this._track_dom.call(this, Fr, arguments); }, Sn.prototype.time_event = function (e) { Ht.isUndefined(e) ? this.report_error("No event name provided to mixpanel.time_event") : this._event_is_disabled(e) || this.persistence.set_event_timer(e, (new Date).getTime()); }; var wn = { persistent: !0 }, In = function (e) { var t; return t = Ht.isObject(e) ? e : Ht.isUndefined(e) ? {} : { days: e }, Ht.extend({}, wn, t); }; Sn.prototype.register = function (e, t) { var r = In(t); r.persistent ? this.persistence.register(e, r.days) : Ht.extend(this.unpersisted_superprops, e); }, Sn.prototype.register_once = function (e, t, r) { var n = In(r); n.persistent ? this.persistence.register_once(e, t, n.days) : (void 0 === t && (t = "None"), Ht.each(e, (function (e, r) { this.unpersisted_superprops.hasOwnProperty(r) && this.unpersisted_superprops[r] !== t || (this.unpersisted_superprops[r] = e); }), this)); }, Sn.prototype.unregister = function (e, t) { (t = In(t)).persistent ? this.persistence.unregister(e) : delete this.unpersisted_superprops[e]; }, Sn.prototype._register_single = function (e, t) { var r = {}; r[e] = t, this.register(r); }, Sn.prototype.identify = function (e, t, r, n, o, i, s, a) { var c = this.get_distinct_id(); if (e && c !== e) { if ("string" == typeof e && 0 === e.indexOf(fn)) return this.report_error("distinct_id cannot have $device: prefix"), -1; this.register({ $user_id: e }); } if (!this.get_property("$device_id")) { var u = c; this.register_once({ $had_persisted_distinct_id: !0, $device_id: u }, ""); } e !== c && e !== this.get_property(nn) && (this.unregister(nn), this.register({ distinct_id: e })), this._flags.identify_called = !0, this.people._flush(t, r, n, o, i, s, a), e !== c && this.track("$identify", { distinct_id: e, $anon_distinct_id: c }, { skip_hooks: !0 }); }, Sn.prototype.reset = function () { this.persistence.clear(), this._flags.identify_called = !1; var e = Ht.UUID(); this.register_once({ distinct_id: fn + e, $device_id: e }, ""); }, Sn.prototype.get_distinct_id = function () { return this.get_property("distinct_id"); }, Sn.prototype.alias = function (e, t) { if (e === this.get_property(rn)) return this.report_error("Attempting to create alias for existing People user - aborting."), -2; var r = this; return Ht.isUndefined(t) && (t = this.get_distinct_id()), e !== t ? (this._register_single(nn, e), this.track("$create_alias", { alias: e, distinct_id: t }, { skip_hooks: !0 }, (function () { r.identify(e); }))) : (this.report_error("alias matches current distinct_id - skipping api call."), this.identify(e), -1); }, Sn.prototype.name_tag = function (e) { this._register_single("mp_name_tag", e); }, Sn.prototype.set_config = function (e) { Ht.isObject(e) && (Ht.extend(this.config, e), e.batch_size && Ht.each(this.request_batchers, (function (e) { e.resetBatchSize(); })), this.get_config("persistence_name") || (this.config.persistence_name = this.config.cookie_name), this.get_config("disable_persistence") || (this.config.disable_persistence = this.config.disable_cookie), this.persistence && this.persistence.update_config(this.config), mt.DEBUG = mt.DEBUG || this.get_config("debug")); }, Sn.prototype.get_config = function (e) { return this.config[e]; }, Sn.prototype._run_hook = function (e) { var t = (this.config.hooks[e] || ln).apply(this, Rt.call(arguments, 1)); return void 0 === t && (this.report_error(e + " hook did not return a value"), t = null), t; }, Sn.prototype.get_property = function (e) { return this.persistence.load_prop([e]); }, Sn.prototype.toString = function () { var e = this.get_config("name"); return e !== dn && (e = dn + "." + e), e; }, Sn.prototype._event_is_disabled = function (e) { return Ht.isBlockedUA(Ut) || this._flags.disable_all_events || Ht.include(this.__disabled_events, e); }, Sn.prototype._gdpr_init = function () { "localStorage" === this.get_config("opt_out_tracking_persistence_type") && Ht.localStorage.is_supported() && (!this.has_opted_in_tracking() && this.has_opted_in_tracking({ persistence_type: "cookie" }) && this.opt_in_tracking({ enable_persistence: !1 }), !this.has_opted_out_tracking() && this.has_opted_out_tracking({ persistence_type: "cookie" }) && this.opt_out_tracking({ clear_persistence: !1 }), this.clear_opt_in_out_tracking({ persistence_type: "cookie", enable_persistence: !1 })), this.has_opted_out_tracking() ? this._gdpr_update_persistence({ clear_persistence: !0 }) : this.has_opted_in_tracking() || !this.get_config("opt_out_tracking_by_default") && !Ht.cookie.get("mp_optout") || (Ht.cookie.remove("mp_optout"), this.opt_out_tracking({ clear_persistence: this.get_config("opt_out_persistence_by_default") })); }, Sn.prototype._gdpr_update_persistence = function (e) { var t; if (e && e.clear_persistence) t = !0; else { if (!e || !e.enable_persistence) return; t = !1; } this.get_config("disable_persistence") || this.persistence.disabled === t || this.persistence.set_disabled(t), t ? this.stop_batch_senders() : this._batchers_were_started && this.start_batch_senders(); }, Sn.prototype._gdpr_call_func = function (e, t) { return t = Ht.extend({ track: Ht.bind(this.track, this), persistence_type: this.get_config("opt_out_tracking_persistence_type"), cookie_prefix: this.get_config("opt_out_tracking_cookie_prefix"), cookie_expiration: this.get_config("cookie_expiration"), cross_site_cookie: this.get_config("cross_site_cookie"), cross_subdomain_cookie: this.get_config("cross_subdomain_cookie"), cookie_domain: this.get_config("cookie_domain"), secure_cookie: this.get_config("secure_cookie"), ignore_dnt: this.get_config("ignore_dnt") }, t), Ht.localStorage.is_supported() || (t.persistence_type = "cookie"), e(this.get_config("token"), { track: t.track, trackEventName: t.track_event_name, trackProperties: t.track_properties, persistenceType: t.persistence_type, persistencePrefix: t.cookie_prefix, cookieDomain: t.cookie_domain, cookieExpiration: t.cookie_expiration, crossSiteCookie: t.cross_site_cookie, crossSubdomainCookie: t.cross_subdomain_cookie, secureCookie: t.secure_cookie, ignoreDnt: t.ignore_dnt }); }, Sn.prototype.opt_in_tracking = function (e) { e = Ht.extend({ enable_persistence: !0 }, e), this._gdpr_call_func(ur, e), this._gdpr_update_persistence(e); }, Sn.prototype.opt_out_tracking = function (e) { (e = Ht.extend({ clear_persistence: !0, delete_user: !0 }, e)).delete_user && this.people && this.people._identify_called() && (this.people.delete_user(), this.people.clear_charges()), this._gdpr_call_func(lr, e), this._gdpr_update_persistence(e); }, Sn.prototype.has_opted_in_tracking = function (e) { return this._gdpr_call_func(pr, e); }, Sn.prototype.has_opted_out_tracking = function (e) { return this._gdpr_call_func(dr, e); }, Sn.prototype.clear_opt_in_out_tracking = function (e) { e = Ht.extend({ enable_persistence: !0 }, e), this._gdpr_call_func(_r, e), this._gdpr_update_persistence(e); }, Sn.prototype.report_error = function (e, t) { Gt.error.apply(Gt.error, arguments); try { t || e instanceof Error || (e = new Error(e)), this.get_config("error_reporter")(e, t); } catch (e) { Gt.error(e); } }, Sn.prototype.init = Sn.prototype.init, Sn.prototype.reset = Sn.prototype.reset, Sn.prototype.disable = Sn.prototype.disable, Sn.prototype.time_event = Sn.prototype.time_event, Sn.prototype.track = Sn.prototype.track, Sn.prototype.track_links = Sn.prototype.track_links, Sn.prototype.track_forms = Sn.prototype.track_forms, Sn.prototype.track_pageview = Sn.prototype.track_pageview, Sn.prototype.register = Sn.prototype.register, Sn.prototype.register_once = Sn.prototype.register_once, Sn.prototype.unregister = Sn.prototype.unregister, Sn.prototype.identify = Sn.prototype.identify, Sn.prototype.alias = Sn.prototype.alias, Sn.prototype.name_tag = Sn.prototype.name_tag, Sn.prototype.set_config = Sn.prototype.set_config, Sn.prototype.get_config = Sn.prototype.get_config, Sn.prototype.get_property = Sn.prototype.get_property, Sn.prototype.get_distinct_id = Sn.prototype.get_distinct_id, Sn.prototype.toString = Sn.prototype.toString, Sn.prototype.opt_out_tracking = Sn.prototype.opt_out_tracking, Sn.prototype.opt_in_tracking = Sn.prototype.opt_in_tracking, Sn.prototype.has_opted_out_tracking = Sn.prototype.has_opted_out_tracking, Sn.prototype.has_opted_in_tracking = Sn.prototype.has_opted_in_tracking, Sn.prototype.clear_opt_in_out_tracking = Sn.prototype.clear_opt_in_out_tracking, Sn.prototype.get_group = Sn.prototype.get_group, Sn.prototype.set_group = Sn.prototype.set_group, Sn.prototype.add_group = Sn.prototype.add_group, Sn.prototype.remove_group = Sn.prototype.remove_group, Sn.prototype.track_with_groups = Sn.prototype.track_with_groups, Sn.prototype.start_batch_senders = Sn.prototype.start_batch_senders, Sn.prototype.stop_batch_senders = Sn.prototype.stop_batch_senders, Sn.prototype.start_session_recording = Sn.prototype.start_session_recording, Sn.prototype.stop_session_recording = Sn.prototype.stop_session_recording, Sn.prototype.get_session_recording_properties = Sn.prototype.get_session_recording_properties, Sn.prototype.DEFAULT_API_ROUTES = yn, an.prototype.properties = an.prototype.properties, an.prototype.update_search_keyword = an.prototype.update_search_keyword, an.prototype.update_referrer_info = an.prototype.update_referrer_info, an.prototype.get_cross_subdomain = an.prototype.get_cross_subdomain, an.prototype.clear = an.prototype.clear; var Mn = {}, Cn = function () { cn.init = function (e, t, r) { if (r) return cn[r] || (cn[r] = Mn[r] = kn(e, t, r), cn[r]._loaded()), cn[r]; var n = cn; Mn[dn] ? n = Mn[dn] : e && ((n = kn(e, t, dn))._loaded(), Mn[dn] = n), cn = n, 1 === Jr && (pt[dn] = cn), Ht.each(Mn, (function (e, t) { t !== dn && (cn[t] = e); })), cn._ = Ht; }; }; var xn = (un = function (e, t) { t(); }, Jr = 0, cn = new Sn, Cn(), cn.init(), function () { function e() { e.done || (e.done = !0, bn = !0, _n = !1, Ht.each(Mn, (function (e) { e._dom_loaded(); }))); } if (qt.addEventListener) "complete" === qt.readyState ? e() : qt.addEventListener("DOMContentLoaded", e, !1); else if (qt.attachEvent) { qt.attachEvent("onreadystatechange", e); var t = !1; try { t = null === pt.frameElement; } catch (e) { } qt.documentElement.doScroll && t && function t() { try { qt.documentElement.doScroll("left"); } catch (e) { return void setTimeout(t, 1); } e(); }(); } Ht.register_event(pt, "load", e, !0); }(), cn); function En(e, t) { return e.match(/\\?.|^$/g).reduce(((e, r) => ('"' !== r || e.sQuote ? "'" !== r || e.quote ? e.quote || e.sQuote || r !== t ? e.a[e.a.length - 1] += r : e.a.push("") : (e.sQuote ^= 1, e.a[e.a.length - 1] += r) : (e.quote ^= 1, e.a[e.a.length - 1] += r), e)), { a: [""] }).a; } function On(e) { return e.nodeType === Node.DOCUMENT_FRAGMENT_NODE || e.nodeType === Node.DOCUMENT_NODE; } function Tn(e, t) { const r = e.parentNode; return r && r.host && 11 === r.nodeType ? r.host : r === t ? null : r; } console.log("MIXPANEL SDK IS INJECTED IN THIS TAB\n\ncall\n\tmixpanel.init('you-token')\nto initialize the SDK with your mixpanel project, and then you can use any of the API methods in the docs\nhttps://github.com/mixpanel/mixpanel-js/blob/master/doc/readme.io/javascript-full-api-reference.md#mixpanel\n\n"), window.mixpanel = xn, window.qsDeep = function (e, t = document, r = null) { return function (e, t, r, n = null) { e = function (e) { function t() { n && (s.length > 0 && /^[~+>]$/.test(s[s.length - 1]) && s.push(" "), s.push(n)); } var r, n, o, i, s = [], a = [0], c = 0, u = /(?:[^\\]|(?:^|[^\\])(?:\\\\)+)$/, l = /^\s+$/, p = [/\s+|\/\*|["'>~+[(]/g, /\s+|\/\*|["'[\]()]/g, /\s+|\/\*|["'[\]()]/g, null, /\*\//g]; for (e = e.trim(); ;) { if (n = "", (o = p[a[a.length - 1]]).lastIndex = c, !(r = o.exec(e))) { n = e.substr(c), t(); break; } if ((i = c) < (c = o.lastIndex) - r[0].length && (n = e.substring(i, c - r[0].length)), a[a.length - 1] < 3) { if (t(), "[" === r[0]) a.push(1); else if ("(" === r[0]) a.push(2); else if (/^["']$/.test(r[0])) a.push(3), p[3] = new RegExp(r[0], "g"); else if ("/*" === r[0]) a.push(4); else if (/^[\])]$/.test(r[0]) && a.length > 0) a.pop(); else if (/^(?:\s+|[~+>])$/.test(r[0]) && (s.length > 0 && !l.test(s[s.length - 1]) && 0 === a[a.length - 1] && s.push(" "), 1 === a[a.length - 1] && 5 === s.length && "=" === s[2].charAt(s[2].length - 1) && (s[4] = " " + s[4]), l.test(r[0]))) continue; s.push(r[0]); } else s[s.length - 1] += n, u.test(s[s.length - 1]) && (4 === a[a.length - 1] && (s.length < 2 || l.test(s[s.length - 2]) ? s.pop() : s[s.length - 1] = " ", r[0] = ""), a.pop()), s[s.length - 1] += r[0]; } return s.join("").trim(); }(e); let o = r.querySelector(e); if (document.head.createShadowRoot || document.head.attachShadow) { if (!t && o) return o; return En(e, ",").reduce(((e, o) => { if (!t && e) return e; const i = En(o.replace(/^\s+/g, "").replace(/\s*([>+~]+)\s*/g, "$1"), " ").filter((e => !!e)).map((e => En(e, ">"))), s = i.length - 1, a = function (e = null, t, r = null) { let n = []; if (r) n = r; else { const e = function (t) { for (let r = 0; r < t.length; r++) { const o = t[r]; n.push(o), o.shadowRoot && e(o.shadowRoot.querySelectorAll("*")); } }; t.shadowRoot && e(t.shadowRoot.querySelectorAll("*")), e(t.querySelectorAll("*")); } return e ? n.filter((t => t.matches(e))) : n; }(i[s][i[s].length - 1], r, n), c = function (e, t, r) { return n => { let o = t, i = n, s = !1; for (; i && !On(i);) { let t = !0; if (1 === e[o].length) t = i.matches(e[o]); else { const n = [].concat(e[o]).reverse(); let s = i; for (const e of n) { if (!s || !s.matches(e)) { t = !1; break; } s = Tn(s, r); } } if (t && 0 === o) { s = !0; break; } t && o--, i = Tn(i, r); } return s; }; }(i, s, r); return t ? e = e.concat(a.filter(c)) : (e = a.find(c)) || null; }), t ? [] : null); } return t ? r.querySelectorAll(e) : o; }(e, !0, t, r); }; })();
	EMBED_TRACKING();
}


if (import.meta.url === new URL(`file://${process.argv[1]}`).href) {
	const result = await main({ concurrency: 3, users: 10, headless: true, inject: true, url: "https://soundcloud.com" });
	if (NODE_ENV === 'dev') debugger;
}
